{% extends "base.html" %}

{% block title %}Multi-File Data View - REDLINE{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/virtual-scroll.js') }}"></script>
<script src="{{ url_for('static', filename='js/date-formatter.js') }}"></script>
{% endblock %}

{% block head %}
<style>
    .file-selector {
        background-color: var(--light-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        color: var(--text-primary);
    }
    
    .file-list {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--light-color);
        color: var(--text-primary);
        position: relative;
        z-index: 2;
    }
    
    .file-list::-webkit-scrollbar {
        width: 8px;
    }
    
    .file-list::-webkit-scrollbar-track {
        background: var(--light-color);
        border-radius: 4px;
    }
    
    .file-list::-webkit-scrollbar-thumb {
        background: var(--secondary-color);
        border-radius: 4px;
    }
    
    .file-list::-webkit-scrollbar-thumb:hover {
        background: var(--text-muted);
    }
    
    .file-item {
        padding: 10px 15px;
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        transition: background-color 0.2s;
        position: relative;
        z-index: 3;
        min-height: 50px;
    }
    
    .file-item:hover {
        background-color: var(--secondary-color);
        color: var(--text-white);
    }
    
    .file-item.selected {
        background-color: var(--info-color);
        color: var(--text-white);
        border-left: 4px solid var(--info-color);
    }
    
    .file-item input[type="checkbox"] {
        margin-right: 10px;
        flex-shrink: 0;
        z-index: 4;
    }
    
    .file-info {
        flex: 1;
        font-size: 14px;
        min-width: 0;
        overflow: hidden;
        position: relative;
        z-index: 3;
    }
    
    .file-name {
        font-weight: 500;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        display: block;
        margin-bottom: 2px;
    }
    
    .file-size {
        color: var(--text-muted);
        font-size: 12px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        display: block;
    }
    
    .data-display-area {
        background: var(--light-color);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        min-height: 500px;
    }
    
    .dataset-container {
        margin-bottom: 30px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        overflow: hidden;
    }
    
    .dataset-header {
        background: var(--light-color);
        color: var(--text-primary);
        padding: 15px 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: between;
        align-items: center;
    }
    
    .dataset-title {
        font-weight: 600;
        color: var(--text-primary);
        margin: 0;
    }
    
    .dataset-info {
        color: var(--text-muted);
        font-size: 14px;
        margin: 0;
    }
    
    .dataset-content {
        padding: 0;
    }
    
    .loading-spinner {
        text-align: center;
        padding: 40px;
    }
    
    .spinner-border {
        width: 3rem;
        height: 3rem;
    }
    
    .table-responsive {
        max-height: 400px;
        overflow-y: auto;
    }
    
    /* Virtual scrolling styles */
    .virtual-scroll-container {
        height: 500px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        background-color: var(--light-color);
        margin-bottom: 20px;
    }
    
    .virtual-scroll-header, .virtual-scroll-footer {
        padding: 10px 15px;
        background-color: var(--dark-color);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: var(--text-white);
    }
    
    .virtual-scroll-footer {
        border-top: 1px solid var(--border-color);
        border-bottom: none;
    }
    
    .virtual-scroll-viewport {
        flex-grow: 1;
        overflow-y: auto;
        position: relative;
    }
    
    .virtual-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 0;
    }
    
    .virtual-table thead th {
        position: sticky;
        top: 0;
        background-color: var(--dark-color);
        color: var(--text-white);
        z-index: 1;
        padding: 0.75rem;
        font-weight: 600;
    }
    
    .pagination-info {
        font-size: 0.85rem;
        color: var(--text-secondary);
    }
    
    .table th {
        background-color: var(--dark-color) !important;
        color: var(--text-white) !important;
        font-weight: bold;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    /* Dark theme: use black background for headers */
    body.theme-dark .table th,
    body.theme-dark .table thead.table-dark th,
    body.theme-dark thead.table-dark th {
        background-color: #000000 !important;
        color: #ffffff !important;
    }
    
    .table td {
        vertical-align: middle;
    }
    
    .no-data-message {
        text-align: center;
        padding: 40px;
        color: var(--text-muted);
        font-style: italic;
    }
    
    .load-button {
        background: var(--primary-color);
        color: var(--text-white);
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
    }
    
    .load-button:hover {
        background: var(--primary-color);
    }
    
    .load-button:disabled {
        background: var(--secondary-color);
        cursor: not-allowed;
    }
    
    .clear-button {
        background: var(--danger-color);
        color: var(--text-white);
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        margin-left: 10px;
    }
    
    .clear-button:hover {
        background: var(--danger-color);
    }
    
    /* View Mode Styles - Separate Panels */
    .view-panel {
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        padding: 0;
        margin: 0;
    }
    
    .data-display-area {
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
        padding: 0 !important;
        margin: 0 !important;
    }
    
    /* Ensure parent containers don't constrain width */
    .data-display-area > * {
        width: 100%;
        max-width: 100%;
    }
    
    .view-stacked-panel {
        display: block;
    }
    
    .view-side-by-side-panel {
        display: grid !important;
        grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)) !important;
        gap: 1rem !important;
        align-items: start !important;
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
        grid-auto-flow: row !important;
    }
    
    /* Ensure all containers are grid items and visible */
    .view-side-by-side-panel > * {
        display: block !important;
        visibility: visible !important;
    }
    
    /* Ensure dataset containers are direct grid children */
    .view-side-by-side-panel .dataset-container {
        grid-column: auto !important;
        grid-row: auto !important;
    }
    
    .data-display-area.view-stacked .view-stacked-panel {
        display: block !important;
        visibility: visible !important;
    }
    
    .data-display-area.view-stacked .view-side-by-side-panel {
        display: none !important;
        visibility: hidden !important;
    }
    
    .data-display-area.view-side-by-side .view-stacked-panel {
        display: none !important;
        visibility: hidden !important;
    }
    
    .data-display-area.view-side-by-side .view-side-by-side-panel {
        display: grid !important;
        visibility: visible !important;
    }
    
    .view-stacked-panel .dataset-container {
        display: block;
        margin-bottom: 30px;
    }
    
    .view-side-by-side-panel .dataset-container {
        margin-bottom: 0 !important;
        position: relative;
        min-width: 0 !important;
        display: flex !important;
        flex-direction: column;
        height: fit-content;
        box-sizing: border-box !important;
        align-items: stretch;
        /* Let CSS Grid handle width distribution */
    }
    
    /* Ensure dataset headers align at the same height */
    .view-side-by-side-panel .dataset-header {
        min-height: 60px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        padding: 0.75rem;
        border-bottom: 1px solid var(--border-color);
        position: relative;
    }
    
    /* Drag handle for reordering */
    .view-side-by-side-panel .dataset-container {
        cursor: move;
        transition: opacity 0.2s;
    }
    
    .view-side-by-side-panel .dataset-container.dragging {
        opacity: 0.5;
    }
    
    .view-side-by-side-panel .dataset-container.drag-over {
        border: 2px dashed var(--primary-color);
    }
    
    .drag-handle {
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
        cursor: grab;
        color: var(--text-muted);
        font-size: 1rem;
        padding: 0.25rem;
        z-index: 10;
    }
    
    .drag-handle:hover {
        color: var(--primary-color);
    }
    
    .drag-handle:active {
        cursor: grabbing;
    }
    
    .view-side-by-side-panel .dataset-title {
        margin: 0;
        font-size: 0.9rem;
        font-weight: 600;
        line-height: 1.2;
    }
    
    .view-side-by-side-panel .dataset-info {
        margin: 0.25rem 0 0 0;
        font-size: 0.8rem;
        color: var(--text-muted);
    }
    
    .view-side-by-side-panel .dataset-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        margin-top: 0;
    }
    
    .view-side-by-side-panel .table-responsive {
        flex: 1;
        overflow-y: auto;
        max-height: 600px;
    }
    
    /* Ensure tables align properly in side-by-side view */
    .view-side-by-side-panel .table {
        table-layout: fixed;
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin: 0;
    }
    
    .view-side-by-side-panel .table thead {
        position: sticky;
        top: 0;
        z-index: 10;
        background-color: var(--light-color);
    }
    
    .view-side-by-side-panel .table thead th {
        padding: 0.75rem 0.5rem;
        font-weight: 600;
        text-align: left;
        border-bottom: 2px solid var(--border-color);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .view-side-by-side-panel .table tbody tr {
        height: auto;
    }
    
    .view-side-by-side-panel .table td,
    .view-side-by-side-panel .table th {
        vertical-align: top;
        padding: 0.5rem;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }
    
    /* Ensure table-responsive containers align */
    .view-side-by-side-panel .table-responsive {
        width: 100%;
        margin: 0;
        padding: 0;
    }
    
    /* Resizable Columns */
    .resize-handle {
        width: 4px;
        background-color: var(--border-color);
        cursor: col-resize;
        position: relative;
        z-index: 100;
        transition: background-color 0.2s;
        user-select: none;
    }
    
    .resize-handle:hover {
        background-color: var(--primary-color);
    }
    
    .resize-handle.active {
        background-color: var(--primary-color);
    }
    
    /* Zoom Styles */
    .data-display-area.zoom-container {
        transform-origin: top left;
        transition: transform 0.2s ease;
    }
    
    .dataset-container {
        transition: transform 0.2s ease;
    }
    
    /* Responsive: Stack on mobile */
    @media (max-width: 768px) {
        .data-display-area.view-side-by-side #dataDisplay {
            grid-template-columns: 1fr !important;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row mb-3">
        <div class="col-12">
            <div class="btn-group" role="group">
                <a href="/data/" class="btn btn-outline-primary">Single File View</a>
                <a href="/data/multi" class="btn btn-outline-primary active">Multi-File View</a>
            </div>
        </div>
    </div>
    <!-- Data Display Area - Moved to Top -->
    <div class="row mb-4">
        <div class="col-12" style="width: 100%; max-width: 100%; box-sizing: border-box;">
            <div class="data-display-area">
                <h5 class="mb-3">üìä Multi-File Data View</h5>
                <div class="mb-3 d-flex align-items-center gap-2 flex-wrap">
                    <!-- Date Format Selector - Always Visible -->
                    <div class="input-group" style="width: auto;">
                        <label class="input-group-text" for="dateFormatSelect" style="margin-bottom: 0;">
                            <i class="fas fa-calendar-alt me-1"></i>Date Format:
                        </label>
                        <select id="dateFormatSelect" class="form-select" style="width: auto;">
                            <option value="auto">Auto (YYYY-MM-DD)</option>
                            <option value="YYYY-MM-DD">YYYY-MM-DD</option>
                            <option value="MM/DD/YYYY">MM/DD/YYYY</option>
                            <option value="DD/MM/YYYY">DD/MM/YYYY</option>
                            <option value="YYYY/MM/DD">YYYY/MM/DD</option>
                            <option value="DD-MM-YYYY">DD-MM-YYYY</option>
                            <option value="MM-DD-YYYY">MM-DD-YYYY</option>
                            <option value="raw">Raw (No Formatting)</option>
                        </select>
                    </div>
                    <!-- View Mode Toggle - Side-by-Side Only -->
                    <div class="btn-group" role="group">
                        <button class="btn btn-sm btn-outline-primary active" id="viewSideBySideBtn" onclick="setViewMode('side-by-side')" title="Side-by-Side View">
                            <i class="fas fa-columns"></i> Side-by-Side
                        </button>
                    </div>
                    <!-- Zoom Controls -->
                    <div class="btn-group" role="group">
                        <button class="btn btn-sm btn-outline-secondary" onclick="adjustZoom(-0.1)" title="Zoom Out">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <button class="btn btn-sm btn-outline-secondary" onclick="resetZoom()" title="Reset Zoom" id="zoomLevelBtn">
                            100%
                        </button>
                        <button class="btn btn-sm btn-outline-secondary" onclick="adjustZoom(0.1)" title="Zoom In">
                            <i class="fas fa-search-plus"></i>
                        </button>
                    </div>
                    <!-- Column Names Editor Button -->
                    <button class="btn btn-sm btn-outline-info" onclick="showColumnEditor()" title="Edit column names" id="editColumnsBtn">
                        <i class="fas fa-edit"></i> Edit Columns
                    </button>
                </div>
                <!-- Stacked View Panel -->
                <div id="dataDisplay" class="view-panel view-stacked-panel">
                    <div class="no-data-message">
                        <i class="fas fa-database fa-3x mb-3"></i>
                        <h6>No files loaded</h6>
                        <p>Select files from the left panel and click "Load Selected Files" to view data</p>
                    </div>
                </div>
                
                <!-- Side-by-Side View Panel -->
                <div id="dataDisplaySideBySide" class="view-panel view-side-by-side-panel" style="display: none;">
                    <div class="no-data-message">
                        <i class="fas fa-database fa-3x mb-3"></i>
                        <h6>No files loaded</h6>
                        <p>Select files from the left panel and click "Load Selected Files" to view data</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- File Selector Panel - Moved Below Data Display -->
    <div class="row">
        <div class="col-md-12">
            <div class="file-selector">
                <h5 class="mb-3">üìÅ Select Files to Load</h5>
                <div class="mb-3">
                    <button id="loadSelectedBtn" class="load-button">
                        Load Selected Files
                    </button>
                    <button id="clearAllBtn" class="clear-button">
                        Clear All
                    </button>
                </div>
                
                <div class="file-list" id="fileList">
                    <div class="text-center p-3">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading files...</span>
                        </div>
                        <p class="mt-2 mb-0">Loading file list...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
let selectedFiles = new Set();
let loadedDatasets = new Map();
// Store column mappings per file: { filename: { oldName: newName } }
let columnMappings = new Map();

// Load file list on page load
document.addEventListener('DOMContentLoaded', function() {
    loadFileList();
    
    // Load saved date format preference
    const savedDateFormat = localStorage.getItem('redline-date-format') || 'auto';
    const dateFormatSelect = document.getElementById('dateFormatSelect');
    if (dateFormatSelect) {
        dateFormatSelect.value = savedDateFormat;
        
        // Date format change handler
        dateFormatSelect.addEventListener('change', function() {
            const selectedFormat = this.value;
            localStorage.setItem('redline-date-format', selectedFormat);
            console.log('Date format changed to:', selectedFormat);
            
            // Re-render all loaded datasets with new date format
            if (loadedDatasets.size > 0) {
                console.log('Re-rendering all datasets with new date format');
                // Force full re-render by clearing existing containers
                document.querySelectorAll('.dataset-container[data-filename]').forEach(container => {
                    container.remove();
                });
                updateDataDisplay();
            }
        });
    }
    
    // Event listeners
    document.getElementById('loadSelectedBtn').addEventListener('click', loadSelectedFiles);
    document.getElementById('clearAllBtn').addEventListener('click', clearAllData);
});

// Load file list from API
async function loadFileList() {
    // Get license key - use global function if available, otherwise fallback
    const licenseKey = (typeof window.getLicenseKey === 'function') 
        ? window.getLicenseKey() 
        : (localStorage.getItem('redline_license_key') || window.REDLINE_LICENSE_KEY);
    
    try {
        const response = await fetch('/api/files', {
            method: 'GET',
            headers: licenseKey ? { 'X-License-Key': licenseKey } : {}
        });
        const data = await response.json();
        
        if (data.files && data.files.length > 0) {
            displayFileList(data.files);
        } else {
            document.getElementById('fileList').innerHTML = 
                '<div class="text-center p-3 text-muted">No files found</div>';
        }
    } catch (error) {
        console.error('Error loading files:', error);
        document.getElementById('fileList').innerHTML = 
            '<div class="text-center p-3 text-danger">Error loading files</div>';
    }
}

// Display file list with checkboxes
function displayFileList(files) {
    const fileList = document.getElementById('fileList');
    
    fileList.innerHTML = files.map(file => `
        <div class="file-item" data-filename="${file.name}">
            <input type="checkbox" id="file-${file.name}" 
                   onchange="toggleFileSelection('${file.name}')">
            <div class="file-info">
                <div class="file-name">${file.name}</div>
                <div class="file-size">${formatFileSize(file.size)} ‚Ä¢ ${formatDate(file.modified)}</div>
            </div>
        </div>
    `).join('');
    
    // Ensure button state is correct after file list is displayed
    updateLoadButtonState();
}

// Update load button state (button is always enabled)
function updateLoadButtonState() {
    // Button is always enabled - no state changes needed
    // This function is kept for compatibility but does nothing
}

// Toggle file selection
function toggleFileSelection(filename) {
    const checkbox = document.getElementById(`file-${filename}`);
    const fileItem = document.querySelector(`[data-filename="${filename}"]`);
    
    if (checkbox && checkbox.checked) {
        selectedFiles.add(filename);
        if (fileItem) {
            fileItem.classList.add('selected');
        }
    } else {
        selectedFiles.delete(filename);
        if (fileItem) {
            fileItem.classList.remove('selected');
        }
    }
    
    // Update load button state
    updateLoadButtonState();
}

// Load selected files
async function loadSelectedFiles() {
    if (selectedFiles.size === 0) {
        alert('Please select at least one file to load.');
        return;
    }
    
    const loadBtn = document.getElementById('loadSelectedBtn');
    const originalText = loadBtn.textContent;
    loadBtn.disabled = true;
    loadBtn.textContent = 'Loading...';
    
    try {
        // Show loading states for all selected files
        const filenames = Array.from(selectedFiles);
        filenames.forEach(filename => showLoadingState(filename));
        
        // Get license key - use global function if available, otherwise fallback
        const licenseKey = (typeof window.getLicenseKey === 'function') 
            ? window.getLicenseKey() 
            : (localStorage.getItem('redline_license_key') || window.REDLINE_LICENSE_KEY);
        
        if (!licenseKey) {
            alert('License key is required. Please register or enter your license key.');
            loadBtn.disabled = false;
            loadBtn.textContent = originalText || 'Load Selected Files';
            return;
        }
        
        // Load all files using batch endpoint
        const response = await fetch('/data/load-multiple', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-License-Key': licenseKey
            },
            body: JSON.stringify({ 
                filenames: filenames,
                license_key: licenseKey
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        // Handle successful loads - ADD to existing datasets (don't overwrite)
        if (result.results && typeof result.results === 'object') {
            Object.entries(result.results).forEach(([filename, data]) => {
                // Store original columns if not already stored
                if (!data.originalColumns) {
                    if (data.columns && Array.isArray(data.columns)) {
                        data.originalColumns = [...data.columns];
                    } else if (data.data && data.data.length > 0) {
                        data.originalColumns = Object.keys(data.data[0]);
                    }
                }
                // Only add if not already loaded, or update if it exists
                loadedDatasets.set(filename, data);
                console.log(`[${filename}] Loaded with originalColumns:`, data.originalColumns);
            });
        }
        
        // Handle errors - show error state but don't remove from loadedDatasets if it was already loaded
        if (result.errors && typeof result.errors === 'object') {
            Object.entries(result.errors).forEach(([filename, error]) => {
                // Only show error if file wasn't already successfully loaded
                if (!loadedDatasets.has(filename)) {
                    showErrorState(filename, error);
                } else {
                    console.warn(`[${filename}] Error loading but file already in loadedDatasets, keeping existing data`);
                }
            });
        }
        
        // Update display - this will show ALL loaded files (existing + new)
        updateDataDisplay();
        
        // Smart loading: Auto-optimize small files (< 1000 rows)
        setTimeout(async () => {
            loadedDatasets.forEach(async (data, filename) => {
                if (data.total_rows && data.total_rows < 1000 && data.pagination && data.pagination.pages > 1) {
                    console.log(`[${filename}] Auto-optimizing: ${data.total_rows} rows, reloading with max page size`);
                    try {
                        await loadPageForFile(filename, 1, 1000);
                    } catch (error) {
                        console.warn(`[${filename}] Failed to auto-optimize:`, error);
                    }
                }
            });
        }, 500);
        
        // Clear selection (but keep loadedDatasets intact)
        selectedFiles.clear();
        document.querySelectorAll('.file-item').forEach(item => {
            item.classList.remove('selected');
            const checkbox = item.querySelector('input[type="checkbox"]');
            if (checkbox) checkbox.checked = false;
        });
        
        // Update load button state
        updateLoadButtonState();
        
        // Show summary
        if (result.error_count > 0) {
            alert(`Loaded ${result.success_count} files successfully. ${result.error_count} files had errors. Check console for details.`);
        }
        
    } catch (error) {
        console.error('Error loading files:', error);
        alert('Error loading files. Check console for details.');
    } finally {
        loadBtn.disabled = false;
        loadBtn.textContent = originalText || 'Load Selected Files';
    }
}

// Load data for a single file
async function loadFileData(filename) {
    // Get license key - use global function if available, otherwise fallback
    const licenseKey = (typeof window.getLicenseKey === 'function') 
        ? window.getLicenseKey() 
        : (localStorage.getItem('redline_license_key') || window.REDLINE_LICENSE_KEY);
    
    if (!licenseKey) {
        console.error('No license key found!');
        showErrorState(filename, 'License key is required');
        return;
    }
    
    try {
        // Show loading state for this file
        showLoadingState(filename);
        
        const response = await fetch('/data/load', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-License-Key': licenseKey
            },
            body: JSON.stringify({ 
                filename: filename,
                license_key: licenseKey
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Store original columns if not already stored
        if (!data.originalColumns) {
            if (data.columns && Array.isArray(data.columns)) {
                data.originalColumns = [...data.columns];
            } else if (data.data && data.data.length > 0) {
                data.originalColumns = Object.keys(data.data[0]);
            }
        }
        
        // Store loaded data
        loadedDatasets.set(filename, data);
        console.log(`[${filename}] Loaded with originalColumns:`, data.originalColumns);
        
        // Update display
        updateDataDisplay();
        
    } catch (error) {
        console.error(`Error loading ${filename}:`, error);
        showErrorState(filename, error.message);
    }
}

// Show loading state for a file
function showLoadingState(filename) {
    const dataDisplay = document.getElementById('dataDisplay');
    
    // If this is the first file being loaded, clear the "no data" message
    if (loadedDatasets.size === 0) {
        dataDisplay.innerHTML = '';
    }
    
    // Add loading indicator for this file to both panels
    const loadingId = `loading-${filename}`;
    if (!document.getElementById(loadingId)) {
        const loadingHtml = `
            <div id="${loadingId}" class="dataset-container">
                <div class="dataset-header">
                    <h6 class="dataset-title">‚è≥ ${filename}</h6>
                    <p class="dataset-info">Loading...</p>
                </div>
                <div class="dataset-content">
                    <div class="loading-spinner">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-2">Loading ${filename}...</p>
                    </div>
                </div>
            </div>
        `;
        if (dataDisplay) {
            dataDisplay.insertAdjacentHTML('beforeend', loadingHtml);
        }
        const dataDisplaySideBySide = document.getElementById('dataDisplaySideBySide');
        if (dataDisplaySideBySide) {
            dataDisplaySideBySide.insertAdjacentHTML('beforeend', loadingHtml);
        }
    }
}

// Show error state for a file
function showErrorState(filename, errorMessage) {
    const loadingId = `loading-${filename}`;
    const loadingDiv = document.getElementById(loadingId);
    
    if (loadingDiv) {
        loadingDiv.innerHTML = `
            <div class="dataset-header">
                <h6 class="dataset-title">‚ùå ${filename}</h6>
                <p class="dataset-info">Error loading file</p>
            </div>
            <div class="dataset-content">
                <div class="no-data-message">
                    <h6>Error loading ${filename}</h6>
                    <p class="text-danger">${errorMessage}</p>
                </div>
            </div>
        `;
    }
}

// Update the data display with all loaded datasets
function updateDataDisplay() {
    const dataDisplay = document.getElementById('dataDisplay');
    const dataDisplaySideBySide = document.getElementById('dataDisplaySideBySide');
    
    if (loadedDatasets.size === 0) {
        const emptyMessage = `
            <div class="no-data-message">
                <i class="fas fa-database fa-3x mb-3"></i>
                <h6>No files loaded</h6>
                <p>Select files from the left panel and click "Load Selected Files" to view data</p>
            </div>
        `;
        if (dataDisplay) dataDisplay.innerHTML = emptyMessage;
        if (dataDisplaySideBySide) dataDisplaySideBySide.innerHTML = emptyMessage;
        return;
    }
    
    // Build a map of existing dataset containers to preserve them if data hasn't changed
    // Check both panels
    const existingContainers = new Map();
    [dataDisplay, dataDisplaySideBySide].forEach(panel => {
        if (panel) {
            panel.querySelectorAll('.dataset-container[data-filename]').forEach(container => {
                const filename = container.getAttribute('data-filename');
                if (filename && loadedDatasets.has(filename) && !existingContainers.has(filename)) {
                    existingContainers.set(filename, container);
                }
            });
        }
    });
    
    // Clear only loading indicators (not existing datasets)
    document.querySelectorAll('[id^="loading-"]').forEach(el => {
        // Only remove if the file is now loaded (not still loading)
        const loadingId = el.id;
        const filename = loadingId.replace('loading-', '');
        if (loadedDatasets.has(filename)) {
            el.remove();
        }
    });
    
    // Display all loaded datasets - preserve existing containers when possible
    let html = '';
    const processedFiles = new Set();
    
    loadedDatasets.forEach((data, filename) => {
        processedFiles.add(filename);
        
        // Check if we should preserve existing container
        const existingContainer = existingContainers.get(filename);
        if (existingContainer) {
            // File already displayed, check if we need to update it
            // Only update if data structure changed significantly
            const existingData = existingContainer.dataset.dataHash;
            const newDataHash = JSON.stringify(data.columns) + '_' + (data.total_rows || 0);
            
            if (existingData !== newDataHash) {
                // Data changed, need to re-render
                html += createDatasetHTML(data, filename);
            } else {
                // Data unchanged, preserve existing container
                // Don't add to html, it's already in the DOM
            }
        } else {
            // New file, add to display
            html += createDatasetHTML(data, filename);
        }
    });
    
    // Remove containers for files that are no longer in loadedDatasets (from both panels)
    [dataDisplay, dataDisplaySideBySide].forEach(panel => {
        if (panel) {
            panel.querySelectorAll('.dataset-container[data-filename]').forEach(container => {
                const filename = container.getAttribute('data-filename');
                if (filename && !processedFiles.has(filename)) {
                    container.remove();
                }
            });
        }
    });
    
    // Append new HTML to both panels (only for new or updated files)
    if (html) {
        // Append to stacked view panel
        const stackedLastContainer = Array.from(dataDisplay.querySelectorAll('.dataset-container[data-filename]')).pop();
        if (stackedLastContainer && stackedLastContainer.nextSibling) {
            stackedLastContainer.insertAdjacentHTML('afterend', html);
        } else {
            dataDisplay.insertAdjacentHTML('beforeend', html);
        }
        
        // Append to side-by-side view panel
        const sideBySideLastContainer = Array.from(dataDisplaySideBySide.querySelectorAll('.dataset-container[data-filename]')).pop();
        if (sideBySideLastContainer && sideBySideLastContainer.nextSibling) {
            sideBySideLastContainer.insertAdjacentHTML('afterend', html);
        } else {
            dataDisplaySideBySide.insertAdjacentHTML('beforeend', html);
        }
    }
}

// Create HTML for a single dataset
function createDatasetHTML(data, filename) {
    // Determine columns to use
    let columnsToUse = [];
    if (data.columns && Array.isArray(data.columns) && data.columns.length > 0) {
        columnsToUse = data.columns;
        console.log(`[${filename}] Using columns from data.columns:`, columnsToUse);
    } else if (data.data && data.data.length > 0) {
        // Fallback: extract columns from first row
        columnsToUse = Object.keys(data.data[0]);
        console.log(`[${filename}] Extracted columns from first row:`, columnsToUse);
    } else {
        console.warn(`[${filename}] No columns found and no data to extract from`);
    }
    
    // Apply column mappings if they exist
    // Note: After applyColumnNames(), data.columns and data.data are already updated
    // But if we're rendering fresh data from API, we need to apply mappings
    const mapping = columnMappings.get(filename);
    if (mapping && Object.keys(mapping).length > 0) {
        // If data.columns already has mapped names, use them directly
        // Otherwise, apply the mapping to the original column names
        // Check if columns are already mapped by seeing if any column matches a mapping value
        const isAlreadyMapped = columnsToUse.some(col => Object.values(mapping).includes(col));
        
        if (!isAlreadyMapped) {
            // Apply mapping to original column names
            columnsToUse = columnsToUse.map(col => mapping[col] || col);
        }
        // If already mapped, columnsToUse is already correct
    }
    
    const totalRows = data.total_rows !== undefined ? data.total_rows : (data.data ? data.data.length : 0);
    
    // Create a hash for change detection
    const dataHash = JSON.stringify(columnsToUse) + '_' + totalRows;
    
    // Initialize HTML variable
    let html = '';
    let columnCountText = `Rows: ${totalRows} | Columns: ${columnsToUse.length}`;
    
    if (data.data && data.data.length > 0 && columnsToUse.length > 0) {
        // Use pagination for all files
        // Get pagination info from API response if available, otherwise calculate from data
        const pagination = data.pagination || {};
        const currentPage = pagination.page || 1;
        const pageSize = pagination.per_page || 500;
        const totalPages = pagination.pages || Math.ceil(totalRows / pageSize);
        const startIdx = pagination.page ? (currentPage - 1) * pageSize : 0;
        const endIdx = pagination.page ? Math.min(startIdx + pageSize, totalRows) : Math.min(pageSize, data.data.length);
        // Use data directly from API (already paginated) or slice if needed
        const pageData = data.data;
        
        // Filter out completely empty columns (columns where all values are null/empty/undefined/whitespace)
        // Also filter out columns with empty/null/whitespace names
        const fullData = loadedDatasets.get(filename);
        const dataToCheck = (fullData && fullData.data && fullData.data.length > pageData.length) ? fullData.data : pageData;
        
        // First, filter out columns with problematic names (empty, null, or just commas/whitespace)
        const validColumns = columnsToUse.filter(col => {
            if (col === null || col === undefined) return false;
            const colStr = String(col).trim();
            // Filter out empty strings, whitespace-only, or columns that are just commas
            if (colStr === '' || colStr === ',' || /^[, ]+$/.test(colStr)) return false;
            return true;
        });
        
        // Then filter out columns where all values are empty
        const nonEmptyColumns = validColumns.filter(col => {
            // Check if column has at least one meaningful value
            return dataToCheck.some(row => {
                const value = row[col];
                // Consider empty strings, null, undefined, and whitespace-only strings as empty
                if (value === null || value === undefined || value === '') {
                    return false;
                }
                // Also check if it's a whitespace-only string or just commas
                if (typeof value === 'string') {
                    const trimmed = value.trim();
                    if (trimmed === '' || trimmed === ',' || /^[, ]+$/.test(trimmed)) {
                        return false;
                    }
                }
                return true;
            });
        });
        
        // Use non-empty columns, or fall back to valid columns if filtering removes everything
        const columnsToDisplay = nonEmptyColumns.length > 0 ? nonEmptyColumns : validColumns;
        
        // Build column count text
        const emptyHidden = columnsToUse.length - columnsToDisplay.length;
        columnCountText = `Rows: ${totalRows} | Columns: ${columnsToDisplay.length}`;
        if (emptyHidden > 0) {
            columnCountText += ` (${emptyHidden} empty hidden)`;
        }
        
        html = `
        <div class="dataset-container" data-filename="${filename}" data-data-hash="${dataHash}">
            <div class="dataset-header">
                <h6 class="dataset-title">üìÑ ${filename}</h6>
                <p class="dataset-info">${columnCountText}</p>
            </div>
            <div class="dataset-content">
    `;
        
        html += '<div class="table-responsive" style="overflow-x: auto;">';
        html += '<table class="table table-striped table-hover table-sm" style="border-collapse: collapse; width: 100%;">';
        
        // HTML escape function
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Headers
        html += '<thead class="table-dark"><tr>';
        columnsToDisplay.forEach((col, index) => {
            const displayCol = (col !== null && col !== undefined && col !== '') ? String(col) : `Column_${index + 1}`;
            const escapedCol = escapeHtml(displayCol);
            html += `<th scope="col" style="background-color: var(--dark-color) !important; color: var(--text-white) !important; padding: 0.75rem !important; font-weight: 600 !important; border: 1px solid var(--border-color) !important;">${escapedCol}</th>`;
        });
        html += '</tr></thead>';
        
        // Data rows
        html += '<tbody>';
        pageData.forEach((row, index) => {
            // Skip completely empty rows (all values are null/empty/undefined/whitespace)
            const hasData = columnsToDisplay.some(col => {
                const value = row[col];
                if (value === null || value === undefined || value === '') {
                    return false;
                }
                // Also check if it's a whitespace-only string or just commas
                if (typeof value === 'string') {
                    const trimmed = value.trim();
                    if (trimmed === '' || trimmed === ',' || /^[, ]+$/.test(trimmed)) {
                        return false;
                    }
                }
                return true;
            });
            
            if (!hasData) {
                return; // Skip empty rows
            }
            
            html += '<tr>';
            columnsToDisplay.forEach(col => {
                const value = row[col];
                // Format date values using the same function as single view
                let formattedValue = typeof formatDateValue === 'function' ? formatDateValue(value, col) : value;
                // Format time values if formatTimeValue function is available
                // Use original value, not date-formatted value, for time formatting
                if (typeof formatTimeValue === 'function') {
                    formattedValue = formatTimeValue(value, col);
                }
                let displayValue = '';
                if (formattedValue === null || formattedValue === undefined || formattedValue === '') {
                    displayValue = '&nbsp;';
                } else if (typeof formattedValue === 'string') {
                    const trimmed = formattedValue.trim();
                    // If it's just whitespace or commas, show as empty
                    if (trimmed === '' || trimmed === ',' || /^[, ]+$/.test(trimmed)) {
                        displayValue = '&nbsp;';
                    } else {
                        displayValue = String(formattedValue);
                    }
                } else if (typeof formattedValue === 'number') {
                    displayValue = Number(formattedValue).toLocaleString();
                } else {
                    displayValue = String(formattedValue);
                }
                html += `<td>${displayValue}</td>`;
            });
            html += '</tr>';
        });
        html += '</tbody></table>';
        html += '</div>';
        
        // Pagination controls
        if (totalPages > 1) {
            html += `
                <div class="d-flex justify-content-between align-items-center mt-3">
                    <div class="pagination-info">
                        Showing ${startIdx + 1}-${endIdx} of ${totalRows} rows (Page ${currentPage} of ${totalPages})
                    </div>
                    <div class="btn-group" role="group">
                        <button class="btn btn-sm btn-outline-primary" onclick="loadPageForFile('${filename}', ${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>Previous</button>
                        <button class="btn btn-sm btn-outline-primary" onclick="loadPageForFile('${filename}', ${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>Next</button>
                    </div>
                </div>
            `;
        }
    } else {
        html = `
        <div class="dataset-container" data-filename="${filename}" data-data-hash="${dataHash}">
            <div class="dataset-header">
                <h6 class="dataset-title">üìÑ ${filename}</h6>
                <p class="dataset-info">${columnCountText}</p>
            </div>
            <div class="dataset-content">
                <div class="no-data-message">No data found in file</div>
            </div>
        </div>
    `;
        return html;
    }
    
    html += `
            </div>
        </div>
    `;
    
    return html;
}

// Initialize virtual scrolling after HTML is inserted
function initializeVirtualScrolling(filename, data) {
    const containerId = `virtual-scroll-${filename.replace(/[^a-zA-Z0-9]/g, '-')}`;
    const container = document.getElementById(containerId);
    
    if (!container) return;
    
    // Check if VirtualScrollTable is available
    if (typeof VirtualScrollTable === 'undefined' && typeof window.VirtualScrollTable === 'undefined') {
        console.warn(`[${filename}] VirtualScrollTable not available, falling back to regular table`);
        return;
    }
    
    // Use jQuery if available, otherwise vanilla JS
    const $container = typeof $ !== 'undefined' ? $(container) : null;
    const scrollContainer = $container || container;
    
    // Destroy existing instance if any
    if (window[`virtualScroll_${containerId}`]) {
        window[`virtualScroll_${containerId}`].destroy();
    }
    
    // Initialize virtual scroll
    try {
        const VirtualScroll = window.VirtualScrollTable || VirtualScrollTable;
        window[`virtualScroll_${containerId}`] = new VirtualScroll(scrollContainer, {
            rowHeight: 30,
            visibleRows: 20,
            buffer: 5,
            pageSize: 500
        });
        
        // Load data from API
        const licenseKey = (typeof window.getLicenseKey === 'function') 
            ? window.getLicenseKey() 
            : (localStorage.getItem('redline_license_key') || window.REDLINE_LICENSE_KEY);
        
        window[`virtualScroll_${containerId}`].loadDataFromAPI(`/data/load`, {
            filename: filename,
            license_key: licenseKey
        });
    } catch (error) {
        console.error(`[${filename}] Error initializing virtual scroll:`, error);
    }
}

// Track loading state per file to prevent duplicate requests
const loadingPages = new Map();

// Load page for a specific file (pagination)
async function loadPageForFile(filename, page, perPage = 500) {
    // Prevent duplicate simultaneous requests for the same file/page
    const requestKey = `${filename}_${page}`;
    if (loadingPages.has(requestKey)) {
        console.log(`loadPageForFile: Already loading page ${page} for ${filename}, skipping duplicate request`);
        return;
    }
    
    const licenseKey = (typeof window.getLicenseKey === 'function') 
        ? window.getLicenseKey() 
        : (localStorage.getItem('redline_license_key') || window.REDLINE_LICENSE_KEY);
    
    if (!licenseKey) {
        console.error('loadPageForFile: No license key found');
        alert('License key is required');
        return;
    }
    
    console.log(`loadPageForFile: Loading page ${page} for ${filename}`);
    loadingPages.set(requestKey, true);
    
    try {
        const response = await fetch('/data/load', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-License-Key': licenseKey
            },
            body: JSON.stringify({ 
                filename: filename,
                license_key: licenseKey,
                page: page,
                per_page: perPage
            })
        });
        
        if (!response.ok) {
            // Try to get error message from response
            let errorMsg = `HTTP ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg = errorData.error || errorData.message || errorMsg;
            } catch (e) {
                // If response is not JSON, use status text
                errorMsg = `${errorMsg}: ${response.statusText}`;
            }
            console.error(`loadPageForFile: ${errorMsg} for ${filename} page ${page}`);
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        
        // Apply column mappings if they exist (for pagination)
        const mapping = columnMappings.get(filename);
        if (mapping && Object.keys(mapping).length > 0) {
            // Update columns array
            if (data.columns && Array.isArray(data.columns)) {
                data.columns = data.columns.map(col => mapping[col] || col);
            }
            // Update data rows with new column names
            if (data.data && Array.isArray(data.data)) {
                data.data = data.data.map(row => {
                    const newRow = {};
                    Object.keys(row).forEach(oldKey => {
                        const newKey = mapping[oldKey] || oldKey;
                        newRow[newKey] = row[oldKey];
                    });
                    return newRow;
                });
            }
        }
        
        // Update the dataset
        loadedDatasets.set(filename, data);
        
        // Re-render just this dataset with updated page data
        const container = document.querySelector(`[data-filename="${filename}"]`);
        if (container) {
            const newHtml = createDatasetHTML(data, filename);
            container.outerHTML = newHtml;
        }
    } catch (error) {
        console.error(`Error loading page ${page} for ${filename}:`, error);
        alert(`Error loading page: ${error.message}`);
    } finally {
        // Clear loading flag
        loadingPages.delete(requestKey);
    }
}

// Clear all loaded data
function clearAllData() {
    loadedDatasets.clear();
    selectedFiles.clear();
    
    // Clear checkboxes
    document.querySelectorAll('.file-item input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
    });
    
    // Clear selection styling
    document.querySelectorAll('.file-item').forEach(item => {
        item.classList.remove('selected');
    });
    
    // Update load button
    updateLoadButtonState();
    
    // Clear display
    updateDataDisplay();
}

// Utility functions
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatDate(timestamp) {
    const date = new Date(timestamp * 1000);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
}

// Show column editor modal (adapted from single view)
function showColumnEditor() {
    if (loadedDatasets.size === 0) {
        alert('Please load files first to edit column names.');
        return;
    }
    
    // Get all loaded filenames
    const filenames = Array.from(loadedDatasets.keys());
    
    // If only one file, edit it directly
    // If multiple files, show file selector and global edit option
    let selectedFilename = filenames[0];
    let fileSelectorHtml = '';
    let editModeHtml = '';
    
    // Find all columns across all files (for global edit mode)
    let allColumnsMap = new Map(); // column name -> Set of files that have it
    let commonColumns = [];
    let allUniqueColumns = [];
    
    if (filenames.length > 1) {
        filenames.forEach(filename => {
            const fileData = loadedDatasets.get(filename);
            const originalCols = fileData.originalColumns || fileData.columns || (fileData.data && fileData.data.length > 0 ? Object.keys(fileData.data[0]) : []);
            originalCols.forEach(col => {
                if (!allColumnsMap.has(col)) {
                    allColumnsMap.set(col, new Set());
                }
                allColumnsMap.get(col).add(filename);
            });
        });
        
        // Find columns that exist in ALL files (common columns)
        commonColumns = Array.from(allColumnsMap.entries())
            .filter(([col, files]) => files.size === filenames.length)
            .map(([col]) => col);
        
        // Get all unique columns across all files (for flexible global editing)
        allUniqueColumns = Array.from(allColumnsMap.keys()).sort();
        
        editModeHtml = `
            <div class="mb-3">
                <label class="form-label">Edit Mode:</label>
                <div class="btn-group" role="group" id="editModeGroup">
                    <input type="radio" class="btn-check" name="editMode" id="editModeSingle" value="single" checked>
                    <label class="btn btn-outline-primary" for="editModeSingle">Single File</label>
                    <input type="radio" class="btn-check" name="editMode" id="editModeGlobal" value="global">
                    <label class="btn btn-outline-primary" for="editModeGlobal" title="Edit columns across all files (applies to files that have each column)">
                        Global (${allUniqueColumns.length} total, ${commonColumns.length} common)
                    </label>
                </div>
            </div>
        `;
        
        fileSelectorHtml = `
            <div class="mb-3" id="fileSelectorContainer">
                <label for="columnEditorFileSelect" class="form-label">Select file to edit:</label>
                <select id="columnEditorFileSelect" class="form-select" onchange="updateColumnEditorList()">
                    ${filenames.map(f => `<option value="${f}">${f}</option>`).join('')}
                </select>
            </div>
        `;
    }
    
    // Get columns for selected file
    const data = loadedDatasets.get(selectedFilename);
    // Use current columns (which may already be mapped) for display
    // But we'll use originalColumns for mapping
    const columns = data.columns || (data.data && data.data.length > 0 ? Object.keys(data.data[0]) : []);
    
    // Ensure originalColumns is stored
    if (!data.originalColumns && columns.length > 0) {
        if (data.columns && Array.isArray(data.columns)) {
            data.originalColumns = [...data.columns];
        } else if (data.data && data.data.length > 0) {
            data.originalColumns = Object.keys(data.data[0]);
        }
    }
    
    if (columns.length === 0) {
        alert('No columns found in the selected file.');
        return;
    }
    
    // Create modal dynamically
    const modalHtml = `
        <div class="modal fade" id="columnEditorModal" tabindex="-1" aria-labelledby="columnEditorModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header" style="background-color: var(--light-color); color: var(--text-primary);">
                        <h5 class="modal-title" id="columnEditorModalLabel">
                            <i class="fas fa-edit me-2"></i>Edit Column Names
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body" style="background-color: var(--light-color); color: var(--text-primary);">
                        <p class="text-muted">Edit column names below. Changes will be applied to the displayed data.</p>
                        ${editModeHtml}
                        ${fileSelectorHtml}
                        <div id="columnEditorList" class="list-group">
                            ${columns.map((col, index) => {
                                // Get the original column name (before any mappings)
                                const data = loadedDatasets.get(selectedFilename);
                                const originalColumns = data.originalColumns || columns;
                                const originalCol = originalColumns[index] || col;
                                
                                // Check if there's a mapping for this original column
                                const mapping = columnMappings.get(selectedFilename) || {};
                                const currentName = mapping[originalCol] || col;
                                
                                // Default to single file mode (not global)
                                const filenameAttr = `data-filename="${selectedFilename}"`;
                                
                                return `
                                    <div class="list-group-item d-flex align-items-center">
                                        <label class="form-label mb-0 me-2" style="min-width: 150px;">Column ${index + 1}:</label>
                                        <input type="text" class="form-control column-name-input" data-original="${originalCol}" value="${currentName}" data-index="${index}" ${filenameAttr}>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    <div class="modal-footer" style="background-color: var(--light-color); color: var(--text-primary);">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" onclick="applyColumnNames()">Apply Changes</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if any
    const existingModal = document.getElementById('columnEditorModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Add modal to body
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('columnEditorModal'));
    modal.show();
    
    // Store column information for use in event handlers
    if (filenames.length > 1) {
        const modal = document.getElementById('columnEditorModal');
        modal.dataset.commonColumns = JSON.stringify(commonColumns);
        modal.dataset.allColumns = JSON.stringify(allUniqueColumns);
        modal.dataset.columnsMap = JSON.stringify(Array.from(allColumnsMap.entries()).map(([col, files]) => [col, Array.from(files)]));
        modal.dataset.filenames = JSON.stringify(filenames);
    }
    
    // Add event handlers for edit mode changes
    if (filenames.length > 1) {
        document.getElementById('editModeSingle')?.addEventListener('change', function() {
            if (this.checked) {
                document.getElementById('fileSelectorContainer').style.display = 'block';
                updateColumnEditorList();
            }
        });
        
        document.getElementById('editModeGlobal')?.addEventListener('change', function() {
            if (this.checked) {
                document.getElementById('fileSelectorContainer').style.display = 'none';
                updateColumnEditorListGlobal();
            }
        });
    }
    
    // Clean up on hide
    document.getElementById('columnEditorModal').addEventListener('hidden.bs.modal', function() {
        this.remove();
    });
}

// Update column editor list for global mode
function updateColumnEditorListGlobal() {
    const modal = document.getElementById('columnEditorModal');
    if (!modal) return;
    
    const allColumnsStr = modal.dataset.allColumns;
    const columnsMapStr = modal.dataset.columnsMap;
    const filenamesStr = modal.dataset.filenames;
    
    if (!allColumnsStr || !filenamesStr) return;
    
    const allColumns = JSON.parse(allColumnsStr);
    const columnsMap = columnsMapStr ? new Map(JSON.parse(columnsMapStr).map(([col, files]) => [col, new Set(files)])) : new Map();
    const filenames = JSON.parse(filenamesStr);
    
    const columnList = document.getElementById('columnEditorList');
    if (!columnList) return;
    
    // For global mode, show all columns from all files
    // Group by which files have each column
    // Use the first file that has the column for the current mapped name
    columnList.innerHTML = allColumns.map((origCol, index) => {
        // Find which files have this column
        const filesWithColumn = columnsMap.get(origCol) || new Set();
        const fileCount = filesWithColumn.size;
        
        // Find current name from first file that has this column (or use original)
        let currentName = origCol;
        for (const filename of filenames) {
            if (filesWithColumn.has(filename)) {
                const fileMapping = columnMappings.get(filename) || {};
                currentName = fileMapping[origCol] || origCol;
                break;
            }
        }
        
        // Show which files have this column
        const fileIndicator = fileCount === filenames.length 
            ? '<span class="badge bg-success ms-2">All files</span>'
            : `<span class="badge bg-info ms-2">${fileCount} file(s)</span>`;
        
        return `
            <div class="list-group-item d-flex align-items-center">
                <label class="form-label mb-0 me-2" style="min-width: 150px;">Column ${index + 1}:</label>
                <input type="text" class="form-control column-name-input" data-original="${origCol}" value="${currentName}" data-index="${index}" data-filename="*" data-global="true" style="flex: 1;">
                ${fileIndicator}
            </div>
        `;
    }).join('');
}

// Update column editor list when file selection changes
function updateColumnEditorList() {
    const fileSelect = document.getElementById('columnEditorFileSelect');
    if (!fileSelect) return;
    
    const selectedFilename = fileSelect.value;
    const fileData = loadedDatasets.get(selectedFilename);
    const columns = fileData.columns || (fileData.data && fileData.data.length > 0 ? Object.keys(fileData.data[0]) : []);
    
    const columnList = document.getElementById('columnEditorList');
    if (!columnList) return;
    
    // Get original columns for this file
    const originalColumns = fileData.originalColumns || columns;
    const mapping = columnMappings.get(selectedFilename) || {};
    
    columnList.innerHTML = columns.map((col, index) => {
        // Get the original column name
        const originalCol = originalColumns[index] || col;
        const currentName = mapping[originalCol] || col;
        return `
            <div class="list-group-item d-flex align-items-center">
                <label class="form-label mb-0 me-2" style="min-width: 150px;">Column ${index + 1}:</label>
                <input type="text" class="form-control column-name-input" data-original="${originalCol}" value="${currentName}" data-index="${index}" data-filename="${selectedFilename}">
            </div>
        `;
    }).join('');
}

// Apply column name changes (adapted from single view)
function applyColumnNames() {
    const inputs = document.querySelectorAll('.column-name-input');
    if (inputs.length === 0) return;
    
    // Check if we're in global mode
    const isGlobalMode = inputs.length > 0 && inputs[0].getAttribute('data-global') === 'true';
    console.log('applyColumnNames: isGlobalMode =', isGlobalMode, 'inputs.length =', inputs.length);
    
    // Group inputs by filename
    const changesByFile = new Map();
    
    if (isGlobalMode) {
        // Global mode: apply changes to all files
        const globalMapping = {};
        
        inputs.forEach(input => {
            const original = input.getAttribute('data-original');
            const newName = input.value.trim() || original;
            
            if (original !== newName) {
                globalMapping[original] = newName;
            }
        });
        
        // Apply to all loaded files - only for columns that exist in each file
        const filenames = Array.from(loadedDatasets.keys());
        console.log('Global mode: Processing', filenames.length, 'files:', filenames);
        console.log('Global mode: Collected mappings:', globalMapping);
        
        filenames.forEach(filename => {
            const fileData = loadedDatasets.get(filename);
            
            // Ensure originalColumns is set for this file
            if (!fileData.originalColumns) {
                if (fileData.columns && Array.isArray(fileData.columns)) {
                    fileData.originalColumns = [...fileData.columns];
                } else if (fileData.data && fileData.data.length > 0) {
                    fileData.originalColumns = Object.keys(fileData.data[0]);
                } else {
                    console.warn(`[${filename}] Cannot determine originalColumns, skipping`);
                    return;
                }
            }
            
            const fileOriginalCols = fileData.originalColumns;
            console.log(`[${filename}] Original columns (${fileOriginalCols.length}):`, fileOriginalCols);
            
            // Only include mappings for columns that exist in this file
            const fileSpecificMapping = {};
            Object.keys(globalMapping).forEach(origCol => {
                if (fileOriginalCols.includes(origCol)) {
                    fileSpecificMapping[origCol] = globalMapping[origCol];
                    console.log(`[${filename}] Will map "${origCol}" -> "${globalMapping[origCol]}"`);
                }
            });
            
            if (Object.keys(fileSpecificMapping).length > 0) {
                changesByFile.set(filename, fileSpecificMapping);
                console.log(`[${filename}] Added to changesByFile with`, Object.keys(fileSpecificMapping).length, 'mappings');
            } else {
                console.log(`[${filename}] No mappings to apply (file doesn't have any of the edited columns)`);
            }
        });
        
        console.log('Global mode: Applying mappings to', changesByFile.size, 'files');
    } else {
        // Single file mode: apply to selected file only
        inputs.forEach(input => {
            const filename = input.getAttribute('data-filename');
            const original = input.getAttribute('data-original');
            const newName = input.value.trim() || original;
            
            if (!changesByFile.has(filename)) {
                changesByFile.set(filename, {});
            }
            
            const fileMapping = changesByFile.get(filename);
            if (original !== newName) {
                fileMapping[original] = newName;
            }
        });
    }
    
    // Apply mappings to each file
    console.log('applyColumnNames: Processing', changesByFile.size, 'files');
    changesByFile.forEach((mapping, filename) => {
        console.log(`[${filename}] Applying mapping:`, mapping);
        if (Object.keys(mapping).length > 0) {
            // Get existing mapping BEFORE merging (to know current row key state)
            const existingMapping = columnMappings.get(filename) || {};
            
            // Update the dataset's columns
            const data = loadedDatasets.get(filename);
            if (data) {
                // Store original columns if not already stored
                if (!data.originalColumns) {
                    // Get original columns from data.columns or extract from first row
                    if (data.columns && Array.isArray(data.columns)) {
                        data.originalColumns = [...data.columns];
                        console.log(`[${filename}] Stored originalColumns from data.columns:`, data.originalColumns);
                    } else if (data.data && data.data.length > 0) {
                        data.originalColumns = Object.keys(data.data[0]);
                        console.log(`[${filename}] Stored originalColumns from data keys:`, data.originalColumns);
                    }
                } else {
                    console.log(`[${filename}] Using existing originalColumns:`, data.originalColumns);
                }
                
                // Always map from original columns to new columns
                const originalCols = data.originalColumns || [];
                
                // Merge mappings: existing + new
                const mergedMapping = { ...existingMapping, ...mapping };
                columnMappings.set(filename, mergedMapping);
                console.log(`[${filename}] Merged mapping:`, mergedMapping);
                
                // Update columns array using merged mapping (map from original to new)
                if (originalCols.length > 0) {
                    const newColumns = originalCols.map(origCol => mergedMapping[origCol] || origCol);
                    data.columns = newColumns;
                    console.log(`[${filename}] Updated columns:`, newColumns);
                }
                
                // Update data rows with new column names
                // Row keys should match current data.columns (which may already be mapped)
                // So we need to find values by checking: current row keys (which match current data.columns)
                if (data.data && Array.isArray(data.data) && originalCols.length > 0) {
                    data.data = data.data.map(row => {
                        const newRow = {};
                        // Iterate through original columns
                        originalCols.forEach(origCol => {
                            // Get the new column name from merged mapping
                            const newColName = mergedMapping[origCol] || origCol;
                            
                            // Find the value in the row
                            // Current row keys should match the current data.columns (before this update)
                            // So we need to find what the current column name is for this original
                            const currentColName = existingMapping[origCol] || origCol;
                            
                            // Get value using current column name (what the row currently has)
                            const value = row[currentColName];
                            
                            // Use the new column name
                            newRow[newColName] = value;
                        });
                        return newRow;
                    });
                }
            }
        }
    });
    
    // Force full re-render by clearing existing containers
    const removedCount = document.querySelectorAll('.dataset-container[data-filename]').length;
    document.querySelectorAll('.dataset-container[data-filename]').forEach(container => {
        container.remove();
    });
    console.log('Removed', removedCount, 'dataset containers for re-render');
    
    // Re-render all datasets
    console.log('Re-rendering all datasets. Total loaded:', loadedDatasets.size);
    updateDataDisplay();
    
    // Close modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('columnEditorModal'));
    if (modal) {
        modal.hide();
    }
    
    // Show success message
    if (typeof REDLINE !== 'undefined' && REDLINE.ui && typeof REDLINE.ui.showToast === 'function') {
        REDLINE.ui.showToast('Column names updated successfully', 'success');
    } else {
        alert('Column names updated successfully');
    }
}

// ==================== View Mode Toggle ====================
let currentViewMode = localStorage.getItem('multiViewMode') || 'side-by-side';

// Make function globally accessible
window.setViewMode = function(mode) {
    console.log('setViewMode called with mode:', mode);
    currentViewMode = mode;
    localStorage.setItem('multiViewMode', mode);
    
    const dataDisplay = document.getElementById('dataDisplay');
    const dataDisplayArea = dataDisplay ? dataDisplay.parentElement : null;
    const sideBySideBtn = document.getElementById('viewSideBySideBtn');
    
    console.log('Elements found:', {
        dataDisplay: !!dataDisplay,
        dataDisplayArea: !!dataDisplayArea,
        sideBySideBtn: !!sideBySideBtn
    });
    
    if (!dataDisplay || !dataDisplayArea) {
        console.error('setViewMode: dataDisplay or parent not found', {
            dataDisplay: dataDisplay,
            dataDisplayArea: dataDisplayArea
        });
        return;
    }
    
    const dataDisplaySideBySide = document.getElementById('dataDisplaySideBySide');
    
    // Only side-by-side mode is supported now
    if (mode === 'side-by-side' || mode === 'stacked') {
        dataDisplayArea.classList.add('view-side-by-side');
        dataDisplayArea.classList.remove('view-stacked');
        if (sideBySideBtn) sideBySideBtn.classList.add('active');
        // Show side-by-side panel, hide stacked panel
        if (dataDisplay) {
            dataDisplay.style.display = 'none';
            dataDisplay.style.visibility = 'hidden';
            dataDisplay.setAttribute('hidden', '');
            dataDisplay.classList.add('d-none');
            console.log('Stacked panel hidden');
        }
        if (dataDisplaySideBySide) {
            dataDisplaySideBySide.style.display = 'grid';
            dataDisplaySideBySide.style.visibility = 'visible';
            dataDisplaySideBySide.classList.remove('d-none');
            // Only count containers with actual data (exclude empty/loading containers)
            const containers = Array.from(dataDisplaySideBySide.querySelectorAll('.dataset-container[data-filename]'))
                .filter(container => {
                    const filename = container.getAttribute('data-filename');
                    return filename && loadedDatasets && loadedDatasets.has(filename);
                });
            const containerCount = containers.length;
            
            console.log('Filtered containers:', containerCount, 'from', dataDisplaySideBySide.querySelectorAll('.dataset-container').length, 'total');
            
            // Use explicit columns based on number of files
            // For 2 files: side-by-side (1fr 1fr)
            // For 3 files: three columns side-by-side (1fr 1fr 1fr)
            // For 4 files: four columns side-by-side (1fr 1fr 1fr 1fr)
            // For 5+ files: 2 columns (1fr 1fr) - will wrap to multiple rows
            let gridColumns;
            if (containerCount === 2) {
                gridColumns = '1fr 1fr'; // Two equal columns side-by-side
            } else if (containerCount === 3) {
                gridColumns = '1fr 1fr 1fr'; // Three equal columns side-by-side
            } else if (containerCount === 4) {
                gridColumns = '1fr 1fr 1fr 1fr'; // Four equal columns side-by-side
            } else if (containerCount >= 5) {
                gridColumns = '1fr 1fr'; // Two columns, will wrap to multiple rows
            } else {
                gridColumns = '1fr'; // Single column for 1 file
            }
            
            // Ensure parent containers are full width (fix width constraint)
            let parent = dataDisplaySideBySide.parentElement;
            let depth = 0;
            while (parent && parent !== document.body && depth < 5) {
                const classes = parent.className || '';
                if (classes.includes('col-md-8') || classes.includes('data-display-area') || classes.includes('row')) {
                    parent.style.width = '100%';
                    parent.style.maxWidth = '100%';
                    parent.style.boxSizing = 'border-box';
                    console.log(`Fixed parent width at depth ${depth}:`, parent.className, 'width:', window.getComputedStyle(parent).width);
                }
                parent = parent.parentElement;
                depth++;
            }
            
            dataDisplaySideBySide.style.gridTemplateColumns = gridColumns;
            dataDisplaySideBySide.style.gridAutoFlow = 'row';
            dataDisplaySideBySide.style.gridAutoRows = 'auto';
            dataDisplaySideBySide.style.minWidth = '100%';
            
            // Force recalculation by reading computed style
            const computedWidth = window.getComputedStyle(dataDisplaySideBySide).width;
            console.log('Panel width after fixes:', computedWidth);
            console.log('Grid columns:', gridColumns, 'for', containerCount, 'containers');
            dataDisplaySideBySide.style.gap = '1rem';
            dataDisplaySideBySide.style.width = '100%';
            dataDisplaySideBySide.style.maxWidth = '100%';
            dataDisplaySideBySide.style.alignItems = 'start'; // Align containers at top
            dataDisplaySideBySide.style.boxSizing = 'border-box';
            dataDisplaySideBySide.style.padding = '0';
            dataDisplaySideBySide.style.margin = '0';
            
            // Hide the "no-data-message" div if containers are present
            const noDataMessage = dataDisplaySideBySide.querySelector('.no-data-message');
            if (noDataMessage && containerCount > 0) {
                noDataMessage.style.display = 'none';
            }
            
            // Force containers to be grid items with proper sizing and alignment
            containers.forEach((container, idx) => {
                // Ensure container is a direct child and visible
                if (container.parentElement !== dataDisplaySideBySide) {
                    console.warn(`Container ${idx} is not a direct child of side-by-side panel!`);
                    dataDisplaySideBySide.appendChild(container);
                }
                
                // Reset all width constraints to let grid handle sizing
                container.style.width = '';
                container.style.minWidth = '0';
                container.style.maxWidth = 'none';
                container.style.flex = 'none';
                container.style.boxSizing = 'border-box';
                container.style.margin = '0';
                container.style.padding = '0';
                container.style.display = 'block';
                container.style.visibility = 'visible';
                
                // Ensure headers align at the same height
                const header = container.querySelector('.dataset-header');
                if (header) {
                    header.style.minHeight = '60px';
                    header.style.display = 'flex';
                    header.style.flexDirection = 'column';
                    header.style.justifyContent = 'flex-start';
                    
                    // Add drag handle if not already present
                    if (!header.querySelector('.drag-handle')) {
                        const dragHandle = document.createElement('span');
                        dragHandle.className = 'drag-handle';
                        dragHandle.innerHTML = '‚ãÆ‚ãÆ';
                        dragHandle.title = 'Drag to reorder';
                        dragHandle.setAttribute('draggable', 'true');
                        dragHandle.addEventListener('dragstart', (e) => handleDragStart(e, container));
                        header.appendChild(dragHandle);
                    }
                }
                
                // Make container draggable
                container.setAttribute('draggable', 'true');
                container.addEventListener('dragstart', (e) => handleDragStart(e, container));
                container.addEventListener('dragover', handleDragOver);
                container.addEventListener('drop', (e) => handleDrop(e, container));
                container.addEventListener('dragend', handleDragEnd);
                
                console.log(`Container ${idx}: width=${container.offsetWidth}px, computed width=${window.getComputedStyle(container).width}, parent=${container.parentElement === dataDisplaySideBySide ? 'correct' : 'WRONG'}`);
            });
            
            // Verify all containers are direct children
            const allContainers = dataDisplaySideBySide.querySelectorAll('.dataset-container[data-filename]');
            console.log('Total containers in panel:', allContainers.length, 'Direct children:', dataDisplaySideBySide.children.length);
            allContainers.forEach((container, idx) => {
                if (container.parentElement !== dataDisplaySideBySide) {
                    console.error(`Container ${idx} (${container.getAttribute('data-filename')}) is NOT a direct child! Parent:`, container.parentElement.className);
                }
            });
            
            console.log('Side-by-side panel shown with grid display');
            console.log('Grid columns:', gridColumns, 'for', containerCount, 'containers');
            console.log('Side-by-side panel computed style:', {
                display: window.getComputedStyle(dataDisplaySideBySide).display,
                gridTemplateColumns: window.getComputedStyle(dataDisplaySideBySide).gridTemplateColumns,
                width: window.getComputedStyle(dataDisplaySideBySide).width,
                padding: window.getComputedStyle(dataDisplaySideBySide).padding,
                margin: window.getComputedStyle(dataDisplaySideBySide).margin,
                visibility: window.getComputedStyle(dataDisplaySideBySide).visibility
            });
            console.log('Found', containerCount, 'containers in side-by-side panel');
        } else {
            console.error('dataDisplaySideBySide element not found!');
        }
        setTimeout(() => {
            initResizableColumns();
            initSynchronizedScrolling();
        }, 50);
    }
};

// Initialize view mode on page load and add event listeners
document.addEventListener('DOMContentLoaded', function() {
    // Set initial button states (only side-by-side now)
    const sideBySideBtn = document.getElementById('viewSideBySideBtn');
    
    // Add event listener as backup to onclick
    if (sideBySideBtn) {
        sideBySideBtn.addEventListener('click', function(e) {
            e.preventDefault();
            console.log('Side-by-side button clicked via event listener');
            setViewMode('side-by-side');
        });
    }
    
    // Always use side-by-side mode
    if (sideBySideBtn) sideBySideBtn.classList.add('active');
    setViewMode('side-by-side');
});

// ==================== Zoom Controls ====================
let currentZoom = parseFloat(localStorage.getItem('multiViewZoom')) || 1.0;

function adjustZoom(delta) {
    currentZoom = Math.max(0.5, Math.min(2.0, currentZoom + delta));
    applyZoom();
}

function resetZoom() {
    currentZoom = 1.0;
    applyZoom();
}

function applyZoom() {
    const dataDisplay = document.getElementById('dataDisplay');
    const dataDisplaySideBySide = document.getElementById('dataDisplaySideBySide');
    
    // Apply zoom to the currently visible panel
    const visiblePanel = dataDisplaySideBySide && dataDisplaySideBySide.style.display !== 'none' 
        ? dataDisplaySideBySide 
        : dataDisplay;
    
    if (visiblePanel) {
        visiblePanel.style.transform = `scale(${currentZoom})`;
        visiblePanel.style.transformOrigin = 'top left';
        localStorage.setItem('multiViewZoom', currentZoom);
        
        const zoomBtn = document.getElementById('zoomLevelBtn');
        if (zoomBtn) {
            zoomBtn.textContent = Math.round(currentZoom * 100) + '%';
        }
    }
}

// Initialize zoom on page load
document.addEventListener('DOMContentLoaded', function() {
    applyZoom();
});

// ==================== Resizable Columns ====================
let resizeState = null;

function initResizableColumns() {
    removeResizeHandles(); // Clean up existing handles
    
    const dataDisplaySideBySide = document.getElementById('dataDisplaySideBySide');
    if (!dataDisplaySideBySide) return;
    
    const containers = dataDisplaySideBySide.querySelectorAll('.dataset-container');
    if (containers.length < 2) return;
    
    containers.forEach((container, index) => {
        if (index < containers.length - 1) {
            const handle = document.createElement('div');
            handle.className = 'resize-handle';
            handle.dataset.index = index;
            handle.style.position = 'absolute';
            handle.style.right = '0';
            handle.style.top = '0';
            handle.style.bottom = '0';
            handle.style.width = '4px';
            handle.style.cursor = 'col-resize';
            handle.style.zIndex = '1000';
            
            handle.addEventListener('mousedown', startResize);
            container.style.position = 'relative';
            container.appendChild(handle);
        }
    });
    
    // Update grid template columns based on stored widths
    const storedWidths = JSON.parse(localStorage.getItem('multiViewColumnWidths') || '[]');
    if (storedWidths.length > 0) {
        const dataDisplay = document.getElementById('dataDisplay');
        if (dataDisplay && dataDisplay.parentElement) {
            dataDisplay.parentElement.style.gridTemplateColumns = storedWidths.join(' ');
        }
    }
}

function startResize(e) {
    e.preventDefault();
    const handle = e.target;
    const container = handle.parentElement;
    const containers = Array.from(document.querySelectorAll('.dataset-container'));
    const index = containers.indexOf(container);
    
    if (index === -1 || index >= containers.length - 1) return;
    
    resizeState = {
        handle: handle,
        container: container,
        nextContainer: containers[index + 1],
        startX: e.clientX,
        startWidth: container.offsetWidth,
        nextWidth: containers[index + 1].offsetWidth,
        containers: containers
    };
    
    handle.classList.add('active');
    document.addEventListener('mousemove', doResize);
    document.addEventListener('mouseup', stopResize);
}

function doResize(e) {
    if (!resizeState) return;
    
    const deltaX = e.clientX - resizeState.startX;
    const minWidth = 300;
    
    const newWidth = resizeState.startWidth + deltaX;
    const nextNewWidth = resizeState.nextWidth - deltaX;
    
    if (newWidth >= minWidth && nextNewWidth >= minWidth) {
        resizeState.container.style.width = newWidth + 'px';
        resizeState.nextContainer.style.width = nextNewWidth + 'px';
        
        // Store widths
        const widths = resizeState.containers.map(c => {
            const stored = c.style.width;
            return stored || '1fr';
        });
        localStorage.setItem('multiViewColumnWidths', JSON.stringify(widths));
    }
}

function stopResize() {
    if (resizeState) {
        resizeState.handle.classList.remove('active');
        resizeState = null;
    }
    document.removeEventListener('mousemove', doResize);
    document.removeEventListener('mouseup', stopResize);
}

function removeResizeHandles() {
    document.querySelectorAll('.resize-handle').forEach(handle => handle.remove());
}

// ==================== Drag and Drop Reordering ====================
let draggedContainer = null;

function handleDragStart(e, container) {
    draggedContainer = container;
    container.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', container.innerHTML);
}

function handleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    
    const container = e.currentTarget;
    if (container !== draggedContainer && container.classList.contains('dataset-container')) {
        container.classList.add('drag-over');
    }
    return false;
}

function handleDrop(e, container) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }
    
    if (draggedContainer !== container && draggedContainer && container.classList.contains('dataset-container')) {
        const dataDisplaySideBySide = document.getElementById('dataDisplaySideBySide');
        if (dataDisplaySideBySide) {
            // Get all containers in current order
            const containers = Array.from(dataDisplaySideBySide.querySelectorAll('.dataset-container[data-filename]'));
            const draggedIndex = containers.indexOf(draggedContainer);
            const targetIndex = containers.indexOf(container);
            
            if (draggedIndex !== -1 && targetIndex !== -1) {
                // Remove dragged container
                draggedContainer.remove();
                
                // Insert at new position
                if (targetIndex < draggedIndex) {
                    container.parentElement.insertBefore(draggedContainer, container);
                } else {
                    container.parentElement.insertBefore(draggedContainer, container.nextSibling);
                }
                
                // Save order to localStorage
                const newOrder = Array.from(dataDisplaySideBySide.querySelectorAll('.dataset-container[data-filename]'))
                    .map(c => c.getAttribute('data-filename'));
                localStorage.setItem('multiViewContainerOrder', JSON.stringify(newOrder));
                
                console.log('Containers reordered:', newOrder);
            }
        }
    }
    
    container.classList.remove('drag-over');
    return false;
}

function handleDragEnd(e) {
    if (draggedContainer) {
        draggedContainer.classList.remove('dragging');
        draggedContainer = null;
    }
    
    // Remove drag-over class from all containers
    document.querySelectorAll('.dataset-container.drag-over').forEach(c => {
        c.classList.remove('drag-over');
    });
}

// Restore container order from localStorage
function restoreContainerOrder() {
    const dataDisplaySideBySide = document.getElementById('dataDisplaySideBySide');
    if (!dataDisplaySideBySide) return;
    
    const savedOrder = localStorage.getItem('multiViewContainerOrder');
    if (!savedOrder) return;
    
    try {
        const order = JSON.parse(savedOrder);
        const containers = Array.from(dataDisplaySideBySide.querySelectorAll('.dataset-container[data-filename]'));
        const containerMap = new Map(containers.map(c => [c.getAttribute('data-filename'), c]));
        
        // Reorder containers based on saved order
        order.forEach((filename, index) => {
            const container = containerMap.get(filename);
            if (container) {
                dataDisplaySideBySide.appendChild(container);
            }
        });
        
        console.log('Container order restored:', order);
    } catch (e) {
        console.error('Error restoring container order:', e);
    }
}

// ==================== Synchronized Scrolling ====================
let scrollSyncEnabled = false;
let isScrolling = false;

function initSynchronizedScrolling() {
    if (scrollSyncEnabled) return;
    scrollSyncEnabled = true;
    
    const dataDisplaySideBySide = document.getElementById('dataDisplaySideBySide');
    if (!dataDisplaySideBySide) {
        console.log('Side-by-side panel not found, skipping sync scroll init');
        return;
    }
    
    const tables = dataDisplaySideBySide.querySelectorAll('.table-responsive');
    if (tables.length === 0) {
        console.log('No tables found in side-by-side panel, will retry after data loads');
        return;
    }
    
    tables.forEach(table => {
        table.addEventListener('scroll', handleScrollSync, { passive: true });
    });
    
    console.log('‚úÖ Synchronized scrolling initialized for', tables.length, 'tables');
}

function removeSynchronizedScrolling() {
    scrollSyncEnabled = false;
    const tables = document.querySelectorAll('.table-responsive');
    tables.forEach(table => {
        table.removeEventListener('scroll', handleScrollSync);
    });
}

function handleScrollSync(e) {
    if (isScrolling) return;
    isScrolling = true;
    
    const sourceTable = e.target.closest('.table-responsive');
    if (!sourceTable) {
        isScrolling = false;
        return;
    }
    
    const scrollTop = sourceTable.scrollTop;
    const scrollLeft = sourceTable.scrollLeft;
    
    // Only sync tables in the side-by-side panel
    const dataDisplaySideBySide = document.getElementById('dataDisplaySideBySide');
    if (dataDisplaySideBySide) {
        dataDisplaySideBySide.querySelectorAll('.table-responsive').forEach(table => {
            if (table !== sourceTable) {
                table.scrollTop = scrollTop;
                table.scrollLeft = scrollLeft;
            }
        });
    }
    
    // Debounce
    setTimeout(() => {
        isScrolling = false;
    }, 50);
}

// Smart loading is now integrated into loadSelectedFiles function


// Re-initialize features after updateDataDisplay
const originalUpdateDataDisplay = updateDataDisplay;
updateDataDisplay = function() {
    originalUpdateDataDisplay();
    
    // Re-initialize view features after display update
    setTimeout(() => {
        // Force re-apply view mode to ensure CSS classes are correct
        const mode = currentViewMode || 'stacked';
        setViewMode(mode);
        applyZoom();
        
        // Re-initialize scroll sync if in side-by-side mode
        if (mode === 'side-by-side') {
            scrollSyncEnabled = false; // Reset flag to allow re-init
            initSynchronizedScrolling();
        }
    }, 150);
};
</script>
{% endblock %}
