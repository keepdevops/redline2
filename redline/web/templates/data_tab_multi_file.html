{% extends "base.html" %}

{% block title %}Multi-File Data View - REDLINE{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/virtual-scroll.js') }}"></script>
<script src="{{ url_for('static', filename='js/date-formatter.js') }}"></script>
{% endblock %}

{% block head %}
<style>
    .file-selector {
        background-color: var(--light-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        color: var(--text-primary);
    }
    
    .file-list {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--light-color);
        color: var(--text-primary);
        position: relative;
        z-index: 2;
    }
    
    .file-list::-webkit-scrollbar {
        width: 8px;
    }
    
    .file-list::-webkit-scrollbar-track {
        background: var(--light-color);
        border-radius: 4px;
    }
    
    .file-list::-webkit-scrollbar-thumb {
        background: var(--secondary-color);
        border-radius: 4px;
    }
    
    .file-list::-webkit-scrollbar-thumb:hover {
        background: var(--text-muted);
    }
    
    .file-item {
        padding: 10px 15px;
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        transition: background-color 0.2s;
        position: relative;
        z-index: 3;
        min-height: 50px;
    }
    
    .file-item:hover {
        background-color: var(--secondary-color);
        color: var(--text-white);
    }
    
    .file-item.selected {
        background-color: var(--info-color);
        color: var(--text-white);
        border-left: 4px solid var(--info-color);
    }
    
    .file-item input[type="checkbox"] {
        margin-right: 10px;
        flex-shrink: 0;
        z-index: 4;
    }
    
    .file-info {
        flex: 1;
        font-size: 14px;
        min-width: 0;
        overflow: hidden;
        position: relative;
        z-index: 3;
    }
    
    .file-name {
        font-weight: 500;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        display: block;
        margin-bottom: 2px;
    }
    
    .file-size {
        color: var(--text-muted);
        font-size: 12px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        display: block;
    }
    
    .data-display-area {
        background: var(--light-color);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        min-height: 500px;
    }
    
    .dataset-container {
        margin-bottom: 30px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        overflow: hidden;
    }
    
    .dataset-header {
        background: var(--light-color);
        color: var(--text-primary);
        padding: 15px 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: between;
        align-items: center;
    }
    
    .dataset-title {
        font-weight: 600;
        color: var(--text-primary);
        margin: 0;
    }
    
    .dataset-info {
        color: var(--text-muted);
        font-size: 14px;
        margin: 0;
    }
    
    .dataset-content {
        padding: 0;
    }
    
    .loading-spinner {
        text-align: center;
        padding: 40px;
    }
    
    .spinner-border {
        width: 3rem;
        height: 3rem;
    }
    
    .table-responsive {
        max-height: 400px;
        overflow-y: auto;
    }
    
    /* Virtual scrolling styles */
    .virtual-scroll-container {
        height: 500px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        background-color: var(--light-color);
        margin-bottom: 20px;
    }
    
    .virtual-scroll-header, .virtual-scroll-footer {
        padding: 10px 15px;
        background-color: var(--dark-color);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: var(--text-white);
    }
    
    .virtual-scroll-footer {
        border-top: 1px solid var(--border-color);
        border-bottom: none;
    }
    
    .virtual-scroll-viewport {
        flex-grow: 1;
        overflow-y: auto;
        position: relative;
    }
    
    .virtual-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 0;
    }
    
    .virtual-table thead th {
        position: sticky;
        top: 0;
        background-color: var(--dark-color);
        color: var(--text-white);
        z-index: 1;
        padding: 0.75rem;
        font-weight: 600;
    }
    
    .pagination-info {
        font-size: 0.85rem;
        color: var(--text-secondary);
    }
    
    .table th {
        background-color: var(--dark-color) !important;
        color: var(--text-white) !important;
        font-weight: bold;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    /* Dark theme: use black background for headers */
    body.theme-dark .table th,
    body.theme-dark .table thead.table-dark th,
    body.theme-dark thead.table-dark th {
        background-color: #000000 !important;
        color: #ffffff !important;
    }
    
    .table td {
        vertical-align: middle;
    }
    
    .no-data-message {
        text-align: center;
        padding: 40px;
        color: var(--text-muted);
        font-style: italic;
    }
    
    .load-button {
        background: var(--primary-color);
        color: var(--text-white);
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
    }
    
    .load-button:hover {
        background: var(--primary-color);
    }
    
    .load-button:disabled {
        background: var(--secondary-color);
        cursor: not-allowed;
    }
    
    .clear-button {
        background: var(--danger-color);
        color: var(--text-white);
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        margin-left: 10px;
    }
    
    .clear-button:hover {
        background: var(--danger-color);
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row mb-3">
        <div class="col-12">
            <div class="btn-group" role="group">
                <a href="/data/" class="btn btn-outline-primary">Single File View</a>
                <a href="/data/multi" class="btn btn-outline-primary active">Multi-File View</a>
            </div>
        </div>
    </div>
    <div class="row">
        <!-- File Selector Panel -->
        <div class="col-md-4">
            <div class="file-selector">
                <h5 class="mb-3">üìÅ Select Files to Load</h5>
                <div class="mb-3">
                    <button id="loadSelectedBtn" class="load-button">
                        Load Selected Files
                    </button>
                    <button id="clearAllBtn" class="clear-button">
                        Clear All
                    </button>
                </div>
                
                <div class="file-list" id="fileList">
                    <div class="text-center p-3">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading files...</span>
                        </div>
                        <p class="mt-2 mb-0">Loading file list...</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Data Display Area -->
        <div class="col-md-8">
            <div class="data-display-area">
                <h5 class="mb-3">üìä Multi-File Data View</h5>
                <div class="mb-3 d-flex align-items-center gap-2">
                    <!-- Date Format Selector - Always Visible -->
                    <div class="input-group" style="width: auto;">
                        <label class="input-group-text" for="dateFormatSelect" style="margin-bottom: 0;">
                            <i class="fas fa-calendar-alt me-1"></i>Date Format:
                        </label>
                        <select id="dateFormatSelect" class="form-select" style="width: auto;">
                            <option value="auto">Auto (YYYY-MM-DD)</option>
                            <option value="YYYY-MM-DD">YYYY-MM-DD</option>
                            <option value="MM/DD/YYYY">MM/DD/YYYY</option>
                            <option value="DD/MM/YYYY">DD/MM/YYYY</option>
                            <option value="YYYY/MM/DD">YYYY/MM/DD</option>
                            <option value="DD-MM-YYYY">DD-MM-YYYY</option>
                            <option value="MM-DD-YYYY">MM-DD-YYYY</option>
                            <option value="raw">Raw (No Formatting)</option>
                        </select>
                    </div>
                    <!-- Column Names Editor Button -->
                    <button class="btn btn-sm btn-outline-info" onclick="showColumnEditor()" title="Edit column names" id="editColumnsBtn">
                        <i class="fas fa-edit"></i> Edit Columns
                    </button>
                </div>
                <div id="dataDisplay">
                    <div class="no-data-message">
                        <i class="fas fa-database fa-3x mb-3"></i>
                        <h6>No files loaded</h6>
                        <p>Select files from the left panel and click "Load Selected Files" to view data</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
let selectedFiles = new Set();
let loadedDatasets = new Map();
// Store column mappings per file: { filename: { oldName: newName } }
let columnMappings = new Map();

// Load file list on page load
document.addEventListener('DOMContentLoaded', function() {
    loadFileList();
    
    // Load saved date format preference
    const savedDateFormat = localStorage.getItem('redline-date-format') || 'auto';
    const dateFormatSelect = document.getElementById('dateFormatSelect');
    if (dateFormatSelect) {
        dateFormatSelect.value = savedDateFormat;
        
        // Date format change handler
        dateFormatSelect.addEventListener('change', function() {
            const selectedFormat = this.value;
            localStorage.setItem('redline-date-format', selectedFormat);
            console.log('Date format changed to:', selectedFormat);
            
            // Re-render all loaded datasets with new date format
            if (loadedDatasets.size > 0) {
                console.log('Re-rendering all datasets with new date format');
                // Force full re-render by clearing existing containers
                document.querySelectorAll('.dataset-container[data-filename]').forEach(container => {
                    container.remove();
                });
                updateDataDisplay();
            }
        });
    }
    
    // Event listeners
    document.getElementById('loadSelectedBtn').addEventListener('click', loadSelectedFiles);
    document.getElementById('clearAllBtn').addEventListener('click', clearAllData);
});

// Load file list from API
async function loadFileList() {
    // Get license key - use global function if available, otherwise fallback
    const licenseKey = (typeof window.getLicenseKey === 'function') 
        ? window.getLicenseKey() 
        : (localStorage.getItem('redline_license_key') || window.REDLINE_LICENSE_KEY);
    
    try {
        const response = await fetch('/api/files', {
            method: 'GET',
            headers: licenseKey ? { 'X-License-Key': licenseKey } : {}
        });
        const data = await response.json();
        
        if (data.files && data.files.length > 0) {
            displayFileList(data.files);
        } else {
            document.getElementById('fileList').innerHTML = 
                '<div class="text-center p-3 text-muted">No files found</div>';
        }
    } catch (error) {
        console.error('Error loading files:', error);
        document.getElementById('fileList').innerHTML = 
            '<div class="text-center p-3 text-danger">Error loading files</div>';
    }
}

// Display file list with checkboxes
function displayFileList(files) {
    const fileList = document.getElementById('fileList');
    
    fileList.innerHTML = files.map(file => `
        <div class="file-item" data-filename="${file.name}">
            <input type="checkbox" id="file-${file.name}" 
                   onchange="toggleFileSelection('${file.name}')">
            <div class="file-info">
                <div class="file-name">${file.name}</div>
                <div class="file-size">${formatFileSize(file.size)} ‚Ä¢ ${formatDate(file.modified)}</div>
            </div>
        </div>
    `).join('');
    
    // Ensure button state is correct after file list is displayed
    updateLoadButtonState();
}

// Update load button state (button is always enabled)
function updateLoadButtonState() {
    // Button is always enabled - no state changes needed
    // This function is kept for compatibility but does nothing
}

// Toggle file selection
function toggleFileSelection(filename) {
    const checkbox = document.getElementById(`file-${filename}`);
    const fileItem = document.querySelector(`[data-filename="${filename}"]`);
    
    if (checkbox && checkbox.checked) {
        selectedFiles.add(filename);
        if (fileItem) {
            fileItem.classList.add('selected');
        }
    } else {
        selectedFiles.delete(filename);
        if (fileItem) {
            fileItem.classList.remove('selected');
        }
    }
    
    // Update load button state
    updateLoadButtonState();
}

// Load selected files
async function loadSelectedFiles() {
    if (selectedFiles.size === 0) {
        alert('Please select at least one file to load.');
        return;
    }
    
    const loadBtn = document.getElementById('loadSelectedBtn');
    const originalText = loadBtn.textContent;
    loadBtn.disabled = true;
    loadBtn.textContent = 'Loading...';
    
    try {
        // Show loading states for all selected files
        const filenames = Array.from(selectedFiles);
        filenames.forEach(filename => showLoadingState(filename));
        
        // Get license key - use global function if available, otherwise fallback
        const licenseKey = (typeof window.getLicenseKey === 'function') 
            ? window.getLicenseKey() 
            : (localStorage.getItem('redline_license_key') || window.REDLINE_LICENSE_KEY);
        
        if (!licenseKey) {
            alert('License key is required. Please register or enter your license key.');
            loadBtn.disabled = false;
            loadBtn.textContent = originalText || 'Load Selected Files';
            return;
        }
        
        // Load all files using batch endpoint
        const response = await fetch('/data/load-multiple', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-License-Key': licenseKey
            },
            body: JSON.stringify({ 
                filenames: filenames,
                license_key: licenseKey
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        // Handle successful loads - ADD to existing datasets (don't overwrite)
        if (result.results && typeof result.results === 'object') {
            Object.entries(result.results).forEach(([filename, data]) => {
                // Store original columns if not already stored
                if (!data.originalColumns) {
                    if (data.columns && Array.isArray(data.columns)) {
                        data.originalColumns = [...data.columns];
                    } else if (data.data && data.data.length > 0) {
                        data.originalColumns = Object.keys(data.data[0]);
                    }
                }
                // Only add if not already loaded, or update if it exists
                loadedDatasets.set(filename, data);
                console.log(`[${filename}] Loaded with originalColumns:`, data.originalColumns);
            });
        }
        
        // Handle errors - show error state but don't remove from loadedDatasets if it was already loaded
        if (result.errors && typeof result.errors === 'object') {
            Object.entries(result.errors).forEach(([filename, error]) => {
                // Only show error if file wasn't already successfully loaded
                if (!loadedDatasets.has(filename)) {
                    showErrorState(filename, error);
                } else {
                    console.warn(`[${filename}] Error loading but file already in loadedDatasets, keeping existing data`);
                }
            });
        }
        
        // Update display - this will show ALL loaded files (existing + new)
        updateDataDisplay();
        
        // Clear selection (but keep loadedDatasets intact)
        selectedFiles.clear();
        document.querySelectorAll('.file-item').forEach(item => {
            item.classList.remove('selected');
            const checkbox = item.querySelector('input[type="checkbox"]');
            if (checkbox) checkbox.checked = false;
        });
        
        // Update load button state
        updateLoadButtonState();
        
        // Show summary
        if (result.error_count > 0) {
            alert(`Loaded ${result.success_count} files successfully. ${result.error_count} files had errors. Check console for details.`);
        }
        
    } catch (error) {
        console.error('Error loading files:', error);
        alert('Error loading files. Check console for details.');
    } finally {
        loadBtn.disabled = false;
        loadBtn.textContent = originalText || 'Load Selected Files';
    }
}

// Load data for a single file
async function loadFileData(filename) {
    // Get license key - use global function if available, otherwise fallback
    const licenseKey = (typeof window.getLicenseKey === 'function') 
        ? window.getLicenseKey() 
        : (localStorage.getItem('redline_license_key') || window.REDLINE_LICENSE_KEY);
    
    if (!licenseKey) {
        console.error('No license key found!');
        showErrorState(filename, 'License key is required');
        return;
    }
    
    try {
        // Show loading state for this file
        showLoadingState(filename);
        
        const response = await fetch('/data/load', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-License-Key': licenseKey
            },
            body: JSON.stringify({ 
                filename: filename,
                license_key: licenseKey
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Store original columns if not already stored
        if (!data.originalColumns) {
            if (data.columns && Array.isArray(data.columns)) {
                data.originalColumns = [...data.columns];
            } else if (data.data && data.data.length > 0) {
                data.originalColumns = Object.keys(data.data[0]);
            }
        }
        
        // Store loaded data
        loadedDatasets.set(filename, data);
        console.log(`[${filename}] Loaded with originalColumns:`, data.originalColumns);
        
        // Update display
        updateDataDisplay();
        
    } catch (error) {
        console.error(`Error loading ${filename}:`, error);
        showErrorState(filename, error.message);
    }
}

// Show loading state for a file
function showLoadingState(filename) {
    const dataDisplay = document.getElementById('dataDisplay');
    
    // If this is the first file being loaded, clear the "no data" message
    if (loadedDatasets.size === 0) {
        dataDisplay.innerHTML = '';
    }
    
    // Add loading indicator for this file
    const loadingId = `loading-${filename}`;
    if (!document.getElementById(loadingId)) {
        const loadingDiv = document.createElement('div');
        loadingDiv.id = loadingId;
        loadingDiv.className = 'dataset-container';
        loadingDiv.innerHTML = `
            <div class="dataset-header">
                <h6 class="dataset-title">üìÑ ${filename}</h6>
                <p class="dataset-info">Loading...</p>
            </div>
            <div class="dataset-content">
                <div class="loading-spinner">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2">Loading ${filename}...</p>
                </div>
            </div>
        `;
        dataDisplay.appendChild(loadingDiv);
    }
}

// Show error state for a file
function showErrorState(filename, errorMessage) {
    const loadingId = `loading-${filename}`;
    const loadingDiv = document.getElementById(loadingId);
    
    if (loadingDiv) {
        loadingDiv.innerHTML = `
            <div class="dataset-header">
                <h6 class="dataset-title">‚ùå ${filename}</h6>
                <p class="dataset-info">Error loading file</p>
            </div>
            <div class="dataset-content">
                <div class="no-data-message">
                    <h6>Error loading ${filename}</h6>
                    <p class="text-danger">${errorMessage}</p>
                </div>
            </div>
        `;
    }
}

// Update the data display with all loaded datasets
function updateDataDisplay() {
    const dataDisplay = document.getElementById('dataDisplay');
    
    if (loadedDatasets.size === 0) {
        dataDisplay.innerHTML = `
            <div class="no-data-message">
                <i class="fas fa-database fa-3x mb-3"></i>
                <h6>No files loaded</h6>
                <p>Select files from the left panel and click "Load Selected Files" to view data</p>
            </div>
        `;
        return;
    }
    
    // Build a map of existing dataset containers to preserve them if data hasn't changed
    const existingContainers = new Map();
    document.querySelectorAll('.dataset-container[data-filename]').forEach(container => {
        const filename = container.getAttribute('data-filename');
        if (filename && loadedDatasets.has(filename)) {
            existingContainers.set(filename, container);
        }
    });
    
    // Clear only loading indicators (not existing datasets)
    document.querySelectorAll('[id^="loading-"]').forEach(el => {
        // Only remove if the file is now loaded (not still loading)
        const loadingId = el.id;
        const filename = loadingId.replace('loading-', '');
        if (loadedDatasets.has(filename)) {
            el.remove();
        }
    });
    
    // Display all loaded datasets - preserve existing containers when possible
    let html = '';
    const processedFiles = new Set();
    
    loadedDatasets.forEach((data, filename) => {
        processedFiles.add(filename);
        
        // Check if we should preserve existing container
        const existingContainer = existingContainers.get(filename);
        if (existingContainer) {
            // File already displayed, check if we need to update it
            // Only update if data structure changed significantly
            const existingData = existingContainer.dataset.dataHash;
            const newDataHash = JSON.stringify(data.columns) + '_' + (data.total_rows || 0);
            
            if (existingData !== newDataHash) {
                // Data changed, need to re-render
                html += createDatasetHTML(data, filename);
            } else {
                // Data unchanged, preserve existing container
                // Don't add to html, it's already in the DOM
            }
        } else {
            // New file, add to display
            html += createDatasetHTML(data, filename);
        }
    });
    
    // Remove containers for files that are no longer in loadedDatasets
    existingContainers.forEach((container, filename) => {
        if (!processedFiles.has(filename)) {
            container.remove();
        }
    });
    
    // Append new HTML (only for new or updated files)
    if (html) {
        // If there are existing containers, append after them
        const lastContainer = Array.from(document.querySelectorAll('.dataset-container[data-filename]')).pop();
        if (lastContainer && lastContainer.nextSibling) {
            lastContainer.insertAdjacentHTML('afterend', html);
        } else {
            // No existing containers or last one has no next sibling, append to dataDisplay
            dataDisplay.insertAdjacentHTML('beforeend', html);
        }
    }
}

// Create HTML for a single dataset
function createDatasetHTML(data, filename) {
    // Determine columns to use
    let columnsToUse = [];
    if (data.columns && Array.isArray(data.columns) && data.columns.length > 0) {
        columnsToUse = data.columns;
        console.log(`[${filename}] Using columns from data.columns:`, columnsToUse);
    } else if (data.data && data.data.length > 0) {
        // Fallback: extract columns from first row
        columnsToUse = Object.keys(data.data[0]);
        console.log(`[${filename}] Extracted columns from first row:`, columnsToUse);
    } else {
        console.warn(`[${filename}] No columns found and no data to extract from`);
    }
    
    // Apply column mappings if they exist
    // Note: After applyColumnNames(), data.columns and data.data are already updated
    // But if we're rendering fresh data from API, we need to apply mappings
    const mapping = columnMappings.get(filename);
    if (mapping && Object.keys(mapping).length > 0) {
        // If data.columns already has mapped names, use them directly
        // Otherwise, apply the mapping to the original column names
        // Check if columns are already mapped by seeing if any column matches a mapping value
        const isAlreadyMapped = columnsToUse.some(col => Object.values(mapping).includes(col));
        
        if (!isAlreadyMapped) {
            // Apply mapping to original column names
            columnsToUse = columnsToUse.map(col => mapping[col] || col);
        }
        // If already mapped, columnsToUse is already correct
    }
    
    const totalRows = data.total_rows !== undefined ? data.total_rows : (data.data ? data.data.length : 0);
    
    // Create a hash for change detection
    const dataHash = JSON.stringify(columnsToUse) + '_' + totalRows;
    
    let html = `
        <div class="dataset-container" data-filename="${filename}" data-data-hash="${dataHash}">
            <div class="dataset-header">
                <h6 class="dataset-title">üìÑ ${filename}</h6>
                <p class="dataset-info">Rows: ${totalRows} | Columns: ${columnsToUse.length}</p>
            </div>
            <div class="dataset-content">
    `;
    
    if (data.data && data.data.length > 0 && columnsToUse.length > 0) {
        // Use pagination for all files
        // Get pagination info from API response if available, otherwise calculate from data
        const pagination = data.pagination || {};
        const currentPage = pagination.page || 1;
        const pageSize = pagination.per_page || 500;
        const totalPages = pagination.pages || Math.ceil(totalRows / pageSize);
        const startIdx = pagination.page ? (currentPage - 1) * pageSize : 0;
        const endIdx = pagination.page ? Math.min(startIdx + pageSize, totalRows) : Math.min(pageSize, data.data.length);
        // Use data directly from API (already paginated) or slice if needed
        const pageData = data.data;
        
        html += '<div class="table-responsive" style="overflow-x: auto;">';
        html += '<table class="table table-striped table-hover table-sm" style="border-collapse: collapse; width: 100%;">';
        
        // HTML escape function
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Headers
        html += '<thead class="table-dark"><tr>';
        columnsToUse.forEach((col, index) => {
            const displayCol = (col !== null && col !== undefined && col !== '') ? String(col) : `Column_${index + 1}`;
            const escapedCol = escapeHtml(displayCol);
            html += `<th scope="col" style="background-color: var(--dark-color) !important; color: var(--text-white) !important; padding: 0.75rem !important; font-weight: 600 !important; border: 1px solid var(--border-color) !important;">${escapedCol}</th>`;
        });
        html += '</tr></thead>';
        
        // Data rows
        html += '<tbody>';
        pageData.forEach((row, index) => {
            html += '<tr>';
            columnsToUse.forEach(col => {
                const value = row[col];
                // Format date values using the same function as single view
                const formattedValue = typeof formatDateValue === 'function' ? formatDateValue(value, col) : value;
                let displayValue = '';
                if (formattedValue === null || formattedValue === undefined || formattedValue === '') {
                    displayValue = '';
                } else if (typeof formattedValue === 'number') {
                    displayValue = Number(formattedValue).toLocaleString();
                } else {
                    displayValue = String(formattedValue);
                }
                html += `<td>${displayValue}</td>`;
            });
            html += '</tr>';
        });
        html += '</tbody></table>';
        html += '</div>';
        
        // Pagination controls
        if (totalPages > 1) {
            html += `
                <div class="d-flex justify-content-between align-items-center mt-3">
                    <div class="pagination-info">
                        Showing ${startIdx + 1}-${endIdx} of ${totalRows} rows (Page ${currentPage} of ${totalPages})
                    </div>
                    <div class="btn-group" role="group">
                        <button class="btn btn-sm btn-outline-primary" onclick="loadPageForFile('${filename}', ${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>Previous</button>
                        <button class="btn btn-sm btn-outline-primary" onclick="loadPageForFile('${filename}', ${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>Next</button>
                    </div>
                </div>
            `;
        }
    } else {
        html += '<div class="no-data-message">No data found in file</div>';
    }
    
    html += `
            </div>
        </div>
    `;
    
    return html;
}

// Initialize virtual scrolling after HTML is inserted
function initializeVirtualScrolling(filename, data) {
    const containerId = `virtual-scroll-${filename.replace(/[^a-zA-Z0-9]/g, '-')}`;
    const container = document.getElementById(containerId);
    
    if (!container) return;
    
    // Check if VirtualScrollTable is available
    if (typeof VirtualScrollTable === 'undefined' && typeof window.VirtualScrollTable === 'undefined') {
        console.warn(`[${filename}] VirtualScrollTable not available, falling back to regular table`);
        return;
    }
    
    // Use jQuery if available, otherwise vanilla JS
    const $container = typeof $ !== 'undefined' ? $(container) : null;
    const scrollContainer = $container || container;
    
    // Destroy existing instance if any
    if (window[`virtualScroll_${containerId}`]) {
        window[`virtualScroll_${containerId}`].destroy();
    }
    
    // Initialize virtual scroll
    try {
        const VirtualScroll = window.VirtualScrollTable || VirtualScrollTable;
        window[`virtualScroll_${containerId}`] = new VirtualScroll(scrollContainer, {
            rowHeight: 30,
            visibleRows: 20,
            buffer: 5,
            pageSize: 500
        });
        
        // Load data from API
        const licenseKey = (typeof window.getLicenseKey === 'function') 
            ? window.getLicenseKey() 
            : (localStorage.getItem('redline_license_key') || window.REDLINE_LICENSE_KEY);
        
        window[`virtualScroll_${containerId}`].loadDataFromAPI(`/data/load`, {
            filename: filename,
            license_key: licenseKey
        });
    } catch (error) {
        console.error(`[${filename}] Error initializing virtual scroll:`, error);
    }
}

// Load page for a specific file (pagination)
async function loadPageForFile(filename, page) {
    const licenseKey = (typeof window.getLicenseKey === 'function') 
        ? window.getLicenseKey() 
        : (localStorage.getItem('redline_license_key') || window.REDLINE_LICENSE_KEY);
    
    if (!licenseKey) {
        alert('License key is required');
        return;
    }
    
    try {
        const response = await fetch('/data/load', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-License-Key': licenseKey
            },
            body: JSON.stringify({ 
                filename: filename,
                license_key: licenseKey,
                page: page,
                per_page: 500
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        
        // Apply column mappings if they exist (for pagination)
        const mapping = columnMappings.get(filename);
        if (mapping && Object.keys(mapping).length > 0) {
            // Update columns array
            if (data.columns && Array.isArray(data.columns)) {
                data.columns = data.columns.map(col => mapping[col] || col);
            }
            // Update data rows with new column names
            if (data.data && Array.isArray(data.data)) {
                data.data = data.data.map(row => {
                    const newRow = {};
                    Object.keys(row).forEach(oldKey => {
                        const newKey = mapping[oldKey] || oldKey;
                        newRow[newKey] = row[oldKey];
                    });
                    return newRow;
                });
            }
        }
        
        // Update the dataset
        loadedDatasets.set(filename, data);
        
        // Re-render just this dataset with updated page data
        const container = document.querySelector(`[data-filename="${filename}"]`);
        if (container) {
            const newHtml = createDatasetHTML(data, filename);
            container.outerHTML = newHtml;
        }
    } catch (error) {
        console.error(`Error loading page ${page} for ${filename}:`, error);
        alert(`Error loading page: ${error.message}`);
    }
}

// Clear all loaded data
function clearAllData() {
    loadedDatasets.clear();
    selectedFiles.clear();
    
    // Clear checkboxes
    document.querySelectorAll('.file-item input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
    });
    
    // Clear selection styling
    document.querySelectorAll('.file-item').forEach(item => {
        item.classList.remove('selected');
    });
    
    // Update load button
    updateLoadButtonState();
    
    // Clear display
    updateDataDisplay();
}

// Utility functions
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatDate(timestamp) {
    const date = new Date(timestamp * 1000);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
}

// Show column editor modal (adapted from single view)
function showColumnEditor() {
    if (loadedDatasets.size === 0) {
        alert('Please load files first to edit column names.');
        return;
    }
    
    // Get all loaded filenames
    const filenames = Array.from(loadedDatasets.keys());
    
    // If only one file, edit it directly
    // If multiple files, show file selector and global edit option
    let selectedFilename = filenames[0];
    let fileSelectorHtml = '';
    let editModeHtml = '';
    
    // Find all columns across all files (for global edit mode)
    let allColumnsMap = new Map(); // column name -> Set of files that have it
    let commonColumns = [];
    let allUniqueColumns = [];
    
    if (filenames.length > 1) {
        filenames.forEach(filename => {
            const fileData = loadedDatasets.get(filename);
            const originalCols = fileData.originalColumns || fileData.columns || (fileData.data && fileData.data.length > 0 ? Object.keys(fileData.data[0]) : []);
            originalCols.forEach(col => {
                if (!allColumnsMap.has(col)) {
                    allColumnsMap.set(col, new Set());
                }
                allColumnsMap.get(col).add(filename);
            });
        });
        
        // Find columns that exist in ALL files (common columns)
        commonColumns = Array.from(allColumnsMap.entries())
            .filter(([col, files]) => files.size === filenames.length)
            .map(([col]) => col);
        
        // Get all unique columns across all files (for flexible global editing)
        allUniqueColumns = Array.from(allColumnsMap.keys()).sort();
        
        editModeHtml = `
            <div class="mb-3">
                <label class="form-label">Edit Mode:</label>
                <div class="btn-group" role="group" id="editModeGroup">
                    <input type="radio" class="btn-check" name="editMode" id="editModeSingle" value="single" checked>
                    <label class="btn btn-outline-primary" for="editModeSingle">Single File</label>
                    <input type="radio" class="btn-check" name="editMode" id="editModeGlobal" value="global">
                    <label class="btn btn-outline-primary" for="editModeGlobal" title="Edit columns across all files (applies to files that have each column)">
                        Global (${allUniqueColumns.length} total, ${commonColumns.length} common)
                    </label>
                </div>
            </div>
        `;
        
        fileSelectorHtml = `
            <div class="mb-3" id="fileSelectorContainer">
                <label for="columnEditorFileSelect" class="form-label">Select file to edit:</label>
                <select id="columnEditorFileSelect" class="form-select" onchange="updateColumnEditorList()">
                    ${filenames.map(f => `<option value="${f}">${f}</option>`).join('')}
                </select>
            </div>
        `;
    }
    
    // Get columns for selected file
    const data = loadedDatasets.get(selectedFilename);
    // Use current columns (which may already be mapped) for display
    // But we'll use originalColumns for mapping
    const columns = data.columns || (data.data && data.data.length > 0 ? Object.keys(data.data[0]) : []);
    
    // Ensure originalColumns is stored
    if (!data.originalColumns && columns.length > 0) {
        if (data.columns && Array.isArray(data.columns)) {
            data.originalColumns = [...data.columns];
        } else if (data.data && data.data.length > 0) {
            data.originalColumns = Object.keys(data.data[0]);
        }
    }
    
    if (columns.length === 0) {
        alert('No columns found in the selected file.');
        return;
    }
    
    // Create modal dynamically
    const modalHtml = `
        <div class="modal fade" id="columnEditorModal" tabindex="-1" aria-labelledby="columnEditorModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header" style="background-color: var(--light-color); color: var(--text-primary);">
                        <h5 class="modal-title" id="columnEditorModalLabel">
                            <i class="fas fa-edit me-2"></i>Edit Column Names
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body" style="background-color: var(--light-color); color: var(--text-primary);">
                        <p class="text-muted">Edit column names below. Changes will be applied to the displayed data.</p>
                        ${editModeHtml}
                        ${fileSelectorHtml}
                        <div id="columnEditorList" class="list-group">
                            ${columns.map((col, index) => {
                                // Get the original column name (before any mappings)
                                const data = loadedDatasets.get(selectedFilename);
                                const originalColumns = data.originalColumns || columns;
                                const originalCol = originalColumns[index] || col;
                                
                                // Check if there's a mapping for this original column
                                const mapping = columnMappings.get(selectedFilename) || {};
                                const currentName = mapping[originalCol] || col;
                                
                                // Default to single file mode (not global)
                                const filenameAttr = `data-filename="${selectedFilename}"`;
                                
                                return `
                                    <div class="list-group-item d-flex align-items-center">
                                        <label class="form-label mb-0 me-2" style="min-width: 150px;">Column ${index + 1}:</label>
                                        <input type="text" class="form-control column-name-input" data-original="${originalCol}" value="${currentName}" data-index="${index}" ${filenameAttr}>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    <div class="modal-footer" style="background-color: var(--light-color); color: var(--text-primary);">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" onclick="applyColumnNames()">Apply Changes</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if any
    const existingModal = document.getElementById('columnEditorModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Add modal to body
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('columnEditorModal'));
    modal.show();
    
    // Store column information for use in event handlers
    if (filenames.length > 1) {
        const modal = document.getElementById('columnEditorModal');
        modal.dataset.commonColumns = JSON.stringify(commonColumns);
        modal.dataset.allColumns = JSON.stringify(allUniqueColumns);
        modal.dataset.columnsMap = JSON.stringify(Array.from(allColumnsMap.entries()).map(([col, files]) => [col, Array.from(files)]));
        modal.dataset.filenames = JSON.stringify(filenames);
    }
    
    // Add event handlers for edit mode changes
    if (filenames.length > 1) {
        document.getElementById('editModeSingle')?.addEventListener('change', function() {
            if (this.checked) {
                document.getElementById('fileSelectorContainer').style.display = 'block';
                updateColumnEditorList();
            }
        });
        
        document.getElementById('editModeGlobal')?.addEventListener('change', function() {
            if (this.checked) {
                document.getElementById('fileSelectorContainer').style.display = 'none';
                updateColumnEditorListGlobal();
            }
        });
    }
    
    // Clean up on hide
    document.getElementById('columnEditorModal').addEventListener('hidden.bs.modal', function() {
        this.remove();
    });
}

// Update column editor list for global mode
function updateColumnEditorListGlobal() {
    const modal = document.getElementById('columnEditorModal');
    if (!modal) return;
    
    const allColumnsStr = modal.dataset.allColumns;
    const columnsMapStr = modal.dataset.columnsMap;
    const filenamesStr = modal.dataset.filenames;
    
    if (!allColumnsStr || !filenamesStr) return;
    
    const allColumns = JSON.parse(allColumnsStr);
    const columnsMap = columnsMapStr ? new Map(JSON.parse(columnsMapStr).map(([col, files]) => [col, new Set(files)])) : new Map();
    const filenames = JSON.parse(filenamesStr);
    
    const columnList = document.getElementById('columnEditorList');
    if (!columnList) return;
    
    // For global mode, show all columns from all files
    // Group by which files have each column
    // Use the first file that has the column for the current mapped name
    columnList.innerHTML = allColumns.map((origCol, index) => {
        // Find which files have this column
        const filesWithColumn = columnsMap.get(origCol) || new Set();
        const fileCount = filesWithColumn.size;
        
        // Find current name from first file that has this column (or use original)
        let currentName = origCol;
        for (const filename of filenames) {
            if (filesWithColumn.has(filename)) {
                const fileMapping = columnMappings.get(filename) || {};
                currentName = fileMapping[origCol] || origCol;
                break;
            }
        }
        
        // Show which files have this column
        const fileIndicator = fileCount === filenames.length 
            ? '<span class="badge bg-success ms-2">All files</span>'
            : `<span class="badge bg-info ms-2">${fileCount} file(s)</span>`;
        
        return `
            <div class="list-group-item d-flex align-items-center">
                <label class="form-label mb-0 me-2" style="min-width: 150px;">Column ${index + 1}:</label>
                <input type="text" class="form-control column-name-input" data-original="${origCol}" value="${currentName}" data-index="${index}" data-filename="*" data-global="true" style="flex: 1;">
                ${fileIndicator}
            </div>
        `;
    }).join('');
}

// Update column editor list when file selection changes
function updateColumnEditorList() {
    const fileSelect = document.getElementById('columnEditorFileSelect');
    if (!fileSelect) return;
    
    const selectedFilename = fileSelect.value;
    const fileData = loadedDatasets.get(selectedFilename);
    const columns = fileData.columns || (fileData.data && fileData.data.length > 0 ? Object.keys(fileData.data[0]) : []);
    
    const columnList = document.getElementById('columnEditorList');
    if (!columnList) return;
    
    // Get original columns for this file
    const originalColumns = fileData.originalColumns || columns;
    const mapping = columnMappings.get(selectedFilename) || {};
    
    columnList.innerHTML = columns.map((col, index) => {
        // Get the original column name
        const originalCol = originalColumns[index] || col;
        const currentName = mapping[originalCol] || col;
        return `
            <div class="list-group-item d-flex align-items-center">
                <label class="form-label mb-0 me-2" style="min-width: 150px;">Column ${index + 1}:</label>
                <input type="text" class="form-control column-name-input" data-original="${originalCol}" value="${currentName}" data-index="${index}" data-filename="${selectedFilename}">
            </div>
        `;
    }).join('');
}

// Apply column name changes (adapted from single view)
function applyColumnNames() {
    const inputs = document.querySelectorAll('.column-name-input');
    if (inputs.length === 0) return;
    
    // Check if we're in global mode
    const isGlobalMode = inputs.length > 0 && inputs[0].getAttribute('data-global') === 'true';
    console.log('applyColumnNames: isGlobalMode =', isGlobalMode, 'inputs.length =', inputs.length);
    
    // Group inputs by filename
    const changesByFile = new Map();
    
    if (isGlobalMode) {
        // Global mode: apply changes to all files
        const globalMapping = {};
        
        inputs.forEach(input => {
            const original = input.getAttribute('data-original');
            const newName = input.value.trim() || original;
            
            if (original !== newName) {
                globalMapping[original] = newName;
            }
        });
        
        // Apply to all loaded files - only for columns that exist in each file
        const filenames = Array.from(loadedDatasets.keys());
        console.log('Global mode: Processing', filenames.length, 'files:', filenames);
        console.log('Global mode: Collected mappings:', globalMapping);
        
        filenames.forEach(filename => {
            const fileData = loadedDatasets.get(filename);
            
            // Ensure originalColumns is set for this file
            if (!fileData.originalColumns) {
                if (fileData.columns && Array.isArray(fileData.columns)) {
                    fileData.originalColumns = [...fileData.columns];
                } else if (fileData.data && fileData.data.length > 0) {
                    fileData.originalColumns = Object.keys(fileData.data[0]);
                } else {
                    console.warn(`[${filename}] Cannot determine originalColumns, skipping`);
                    return;
                }
            }
            
            const fileOriginalCols = fileData.originalColumns;
            console.log(`[${filename}] Original columns (${fileOriginalCols.length}):`, fileOriginalCols);
            
            // Only include mappings for columns that exist in this file
            const fileSpecificMapping = {};
            Object.keys(globalMapping).forEach(origCol => {
                if (fileOriginalCols.includes(origCol)) {
                    fileSpecificMapping[origCol] = globalMapping[origCol];
                    console.log(`[${filename}] Will map "${origCol}" -> "${globalMapping[origCol]}"`);
                }
            });
            
            if (Object.keys(fileSpecificMapping).length > 0) {
                changesByFile.set(filename, fileSpecificMapping);
                console.log(`[${filename}] Added to changesByFile with`, Object.keys(fileSpecificMapping).length, 'mappings');
            } else {
                console.log(`[${filename}] No mappings to apply (file doesn't have any of the edited columns)`);
            }
        });
        
        console.log('Global mode: Applying mappings to', changesByFile.size, 'files');
    } else {
        // Single file mode: apply to selected file only
        inputs.forEach(input => {
            const filename = input.getAttribute('data-filename');
            const original = input.getAttribute('data-original');
            const newName = input.value.trim() || original;
            
            if (!changesByFile.has(filename)) {
                changesByFile.set(filename, {});
            }
            
            const fileMapping = changesByFile.get(filename);
            if (original !== newName) {
                fileMapping[original] = newName;
            }
        });
    }
    
    // Apply mappings to each file
    console.log('applyColumnNames: Processing', changesByFile.size, 'files');
    changesByFile.forEach((mapping, filename) => {
        console.log(`[${filename}] Applying mapping:`, mapping);
        if (Object.keys(mapping).length > 0) {
            // Get existing mapping BEFORE merging (to know current row key state)
            const existingMapping = columnMappings.get(filename) || {};
            
            // Update the dataset's columns
            const data = loadedDatasets.get(filename);
            if (data) {
                // Store original columns if not already stored
                if (!data.originalColumns) {
                    // Get original columns from data.columns or extract from first row
                    if (data.columns && Array.isArray(data.columns)) {
                        data.originalColumns = [...data.columns];
                        console.log(`[${filename}] Stored originalColumns from data.columns:`, data.originalColumns);
                    } else if (data.data && data.data.length > 0) {
                        data.originalColumns = Object.keys(data.data[0]);
                        console.log(`[${filename}] Stored originalColumns from data keys:`, data.originalColumns);
                    }
                } else {
                    console.log(`[${filename}] Using existing originalColumns:`, data.originalColumns);
                }
                
                // Always map from original columns to new columns
                const originalCols = data.originalColumns || [];
                
                // Merge mappings: existing + new
                const mergedMapping = { ...existingMapping, ...mapping };
                columnMappings.set(filename, mergedMapping);
                console.log(`[${filename}] Merged mapping:`, mergedMapping);
                
                // Update columns array using merged mapping (map from original to new)
                if (originalCols.length > 0) {
                    const newColumns = originalCols.map(origCol => mergedMapping[origCol] || origCol);
                    data.columns = newColumns;
                    console.log(`[${filename}] Updated columns:`, newColumns);
                }
                
                // Update data rows with new column names
                // Row keys should match current data.columns (which may already be mapped)
                // So we need to find values by checking: current row keys (which match current data.columns)
                if (data.data && Array.isArray(data.data) && originalCols.length > 0) {
                    data.data = data.data.map(row => {
                        const newRow = {};
                        // Iterate through original columns
                        originalCols.forEach(origCol => {
                            // Get the new column name from merged mapping
                            const newColName = mergedMapping[origCol] || origCol;
                            
                            // Find the value in the row
                            // Current row keys should match the current data.columns (before this update)
                            // So we need to find what the current column name is for this original
                            const currentColName = existingMapping[origCol] || origCol;
                            
                            // Get value using current column name (what the row currently has)
                            const value = row[currentColName];
                            
                            // Use the new column name
                            newRow[newColName] = value;
                        });
                        return newRow;
                    });
                }
            }
        }
    });
    
    // Force full re-render by clearing existing containers
    const removedCount = document.querySelectorAll('.dataset-container[data-filename]').length;
    document.querySelectorAll('.dataset-container[data-filename]').forEach(container => {
        container.remove();
    });
    console.log('Removed', removedCount, 'dataset containers for re-render');
    
    // Re-render all datasets
    console.log('Re-rendering all datasets. Total loaded:', loadedDatasets.size);
    updateDataDisplay();
    
    // Close modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('columnEditorModal'));
    if (modal) {
        modal.hide();
    }
    
    // Show success message
    if (typeof REDLINE !== 'undefined' && REDLINE.ui && typeof REDLINE.ui.showToast === 'function') {
        REDLINE.ui.showToast('Column names updated successfully', 'success');
    } else {
        alert('Column names updated successfully');
    }
}
</script>
{% endblock %}
