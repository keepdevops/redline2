version: '3.8'

services:
  redline-dev:
    build:
      context: .
      dockerfile: Dockerfile.webgui.uncompiled
    image: redline-webgui:dev
    container_name: redline-development
    ports:
      - "8080:8080"
    volumes:
      # Data persistence
      - redline-dev-data:/app/data
      - redline-dev-logs:/app/logs
      - redline-dev-config:/app/config
      # Mount Downloads folder for M3 Apple Silicon (bypasses security restrictions)
      # Files are automatically copied from Downloads to data/stooq inside container
      - ~/Downloads:/app/data/downloads:ro  # Read-only mount
      # Mount source code for live development (uncomment for development)
      # - .:/app
    env_file:
      - .env
    environment:
      - FLASK_ENV=development
      - FLASK_DEBUG=1
      - FLASK_APP=web_app.py
      - PYTHONUNBUFFERED=1
      - PYTHONDONTWRITEBYTECODE=0
      - GUNICORN_WORKERS=1
      - GUNICORN_THREADS=2
      - LICENSE_SERVER_URL=http://host.docker.internal:5001
      - REQUIRE_LICENSE_SERVER=false
    restart: unless-stopped
    # Start file watcher in background (auto-copies Downloads to data/stooq)
    # Uses simple polling version (no watchdog dependency needed)
    command: >
      sh -c "
        python3 /app/redline/scripts/watch_downloads_simple.py > /app/logs/file_watcher.log 2>&1 &
        exec gunicorn --bind 0.0.0.0:8080 --workers 1 --threads 2 --timeout 120 web_app:app
      "
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s
    networks:
      - redline-dev-network

  # Optional Redis for caching (development)
  redis-dev:
    image: redis:7-alpine
    container_name: redline-redis-dev
    ports:
      - "6379:6379"
    volumes:
      - redline-dev-redis:/data
    restart: unless-stopped
    networks:
      - redline-dev-network
    profiles:
      - redis
      - full

  # Optional PostgreSQL for advanced development (if needed)
  postgres-dev:
    image: postgres:15-alpine
    container_name: redline-postgres-dev
    environment:
      - POSTGRES_DB=redline_dev
      - POSTGRES_USER=redline
      - POSTGRES_PASSWORD=dev_password
    ports:
      - "5432:5432"
    volumes:
      - redline-dev-postgres:/var/lib/postgresql/data
    restart: unless-stopped
    networks:
      - redline-dev-network
    profiles:
      - postgres
      - full

volumes:
  redline-dev-data:
    driver: local
  redline-dev-logs:
    driver: local
  redline-dev-config:
    driver: local
  redline-dev-redis:
    driver: local
  redline-dev-postgres:
    driver: local

networks:
  redline-dev-network:
    driver: bridge

# Development Commands:
#
# Basic development setup:
#   docker-compose -f docker-compose-dev.yml up -d
#
# With Redis caching:
#   docker-compose -f docker-compose-dev.yml --profile redis up -d
#
# With PostgreSQL database:
#   docker-compose -f docker-compose-dev.yml --profile postgres up -d
#
# Full development stack:
#   docker-compose -f docker-compose-dev.yml --profile full up -d
#
# Live development with source mounting:
#   1. Uncomment the source volume mount above
#   2. docker-compose -f docker-compose-dev.yml up -d
#
# View logs:
#   docker-compose -f docker-compose-dev.yml logs -f redline-dev
#
# Rebuild after changes:
#   docker-compose -f docker-compose-dev.yml up -d --build
#
# Stop development environment:
#   docker-compose -f docker-compose-dev.yml down
#
# Reset development data:
#   docker-compose -f docker-compose-dev.yml down -v
